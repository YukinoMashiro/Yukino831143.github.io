{"meta":{"title":"yukino","subtitle":null,"description":"一枚程序员的日常","author":"yukino","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-10-09T15:19:10.437Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Yukino] 与&nbsp; Yukino&nbsp; （ Yukino ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2022-10-09T15:19:10.453Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura 主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-10-09T15:19:10.453Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2022-10-09T15:19:10.453Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2022-10-09T15:19:10.453Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2022-10-09T15:19:10.453Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"网盘源码解析","slug":"技术/YukinoCloud源码解析","date":"2021-01-31T08:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2021/01/31/技术/YukinoCloud源码解析/","link":"","permalink":"/2021/01/31/技术/YukinoCloud源码解析/","excerpt":"","text":"0. 数据库CREATE TABLE `file_folder` ( `file_folder_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;文件夹ID&#39;, `file_folder_name` varchar(255) DEFAULT NULL COMMENT &#39;文件夹名称&#39;, `parent_folder_id` int(11) DEFAULT &#39;0&#39; COMMENT &#39;父文件夹ID&#39;, `file_store_id` int(11) DEFAULT NULL COMMENT &#39;所属文件仓库ID&#39;, `time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;, PRIMARY KEY (`file_folder_id`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; @AllArgsConstructor @Data @Builder public class FileFolder implements Serializable { /** * 文件夹ID */ private Integer fileFolderId; /** * 文件夹名称 */ private String fileFolderName; /** * 父文件夹ID */ private Integer parentFolderId; /** * 所属文件仓库ID */ private Integer fileStoreId; /** * 创建时间 */ private Date time; } CREATE TABLE `file_store` ( `file_store_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;文件仓库ID&#39;, `user_id` int(11) DEFAULT NULL COMMENT &#39;主人ID&#39;, `current_size` int(11) DEFAULT &#39;0&#39; COMMENT &#39;当前容量（单位KB）&#39;, `max_size` int(11) DEFAULT &#39;1048576&#39; COMMENT &#39;最大容量（单位KB）&#39;, `permission` int(11) DEFAULT &#39;0&#39; COMMENT &#39;仓库权限，0可上传下载、1不允许上传可以下载、2不可以上传下载&#39;, PRIMARY KEY (`file_store_id`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; @AllArgsConstructor @Data @Builder public class FileStore implements Serializable { /** * 文件仓库ID */ private Integer fileStoreId; /** * 主人ID */ private Integer userId; /** * 当前容量（单位KB） */ private Integer currentSize; /** * 最大容量（单位KB） */ private Integer maxSize; /** * 仓库权限：0可上传下载、1只允许下载、2禁止上传下载 */ private Integer permission; } CREATE TABLE `my_file` ( `my_file_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;文件ID&#39;, `my_file_name` varchar(255) DEFAULT NULL COMMENT &#39;文件名&#39;, `file_store_id` int(11) DEFAULT NULL COMMENT &#39;文件仓库ID&#39;, `my_file_path` varchar(255) DEFAULT &#39;/&#39; COMMENT &#39;文件存储路径&#39;, `download_time` int(11) DEFAULT &#39;0&#39; COMMENT &#39;下载次数&#39;, `upload_time` datetime DEFAULT NULL COMMENT &#39;上传时间&#39;, `parent_folder_id` int(11) DEFAULT NULL COMMENT &#39;父文件夹ID&#39;, `size` int(11) DEFAULT NULL COMMENT &#39;文件大小&#39;, `type` int(11) DEFAULT NULL COMMENT &#39;文件类型&#39;, `postfix` varchar(255) DEFAULT NULL COMMENT &#39;文件后缀&#39;, PRIMARY KEY (`my_file_id`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; @AllArgsConstructor @Data @Builder public class MyFile implements Serializable { /** * 文件ID */ private Integer myFileId; /** * 文件名 */ private String myFileName; /** * 文件仓库ID */ private Integer fileStoreId; /** * 文件存储路径 */ private String myFilePath; /** * 下载次数 */ private Integer downloadTime; /** * 上传时间 */ private Date uploadTime; /** * 父文件夹ID */ private Integer parentFolderId; /** * 文件大小 */ private Integer size; /** * 文件类型 */ private Integer type; /** * 文件后缀 */ private String postfix; } CREATE TABLE `temp_file` ( `file_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;临时文件ID&#39;, `file_name` varchar(255) DEFAULT NULL COMMENT &#39;文件名&#39;, `size` varchar(255) DEFAULT NULL COMMENT &#39;文件大小&#39;, `upload_time` datetime DEFAULT NULL COMMENT &#39;上传时间：4小时后删除&#39;, `file_path` varchar(255) DEFAULT NULL COMMENT &#39;文件在FTP上的存放路径&#39;, PRIMARY KEY (`file_id`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; @AllArgsConstructor @Data @Builder public class TempFile implements Serializable { private static final long serialVersionUID = -90736141035866360L; /** * 临时文件ID */ private Integer fileId; /** * 文件名 */ private String fileName; /** * 文件大小 */ private String size; /** * 上传时间：4小时后删除 */ private Date uploadTime; /** * 文件在FTP上的存放路径 */ private String filePath; } CREATE TABLE `user` ( `user_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;用户ID&#39;, `open_id` varchar(255) DEFAULT NULL COMMENT &#39;用户的openid&#39;, `file_store_id` int(11) DEFAULT NULL COMMENT &#39;文件仓库ID&#39;, `user_name` varchar(50) DEFAULT NULL COMMENT &#39;用户名&#39;, `email` varchar(50) DEFAULT &#39; 0000@qq.com&#39; COMMENT &#39;用户邮箱&#39;, `password` varchar(20) DEFAULT NULL COMMENT &#39;密码&#39;, `register_time` datetime DEFAULT NULL COMMENT &#39;注册时间&#39;, `image_path` varchar(255) DEFAULT &#39;&#39; COMMENT &#39;头像地址&#39;, `role` int(11) DEFAULT &#39;1&#39; COMMENT &#39;用户角色,0管理员，1普通用户&#39;, PRIMARY KEY (`user_id`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; @AllArgsConstructor @Data @Builder public class User implements Serializable { /** * 用户ID */ private Integer userId; /** * 用户的openid */ private String openId; /** * 文件仓库ID */ private Integer fileStoreId; /** * 用户名 */ private String userName; /** * 用户邮箱 */ private String email; /** * 用户密码 */ private String password; /** * 注册时间 */ private Date registerTime; /** * 头像地址 */ private String imagePath; /** * 用户角色，0管理员，1普通用户 */ private Integer role; } 1.注册与登录1.1 邮箱注册获取验证码 @ResponseBody @RequestMapping(&quot;/sendCode&quot;) public String sendCode(String userName, String email, String password) { User userByEmail = userService.getUserByEmail(email); if (userByEmail != null) { logger.error(&quot;发送验证码失败！邮箱已被注册！&quot;); return &quot;exitEmail&quot;; } logger.info(&quot;开始发送邮件.../n&quot; + &quot;获取的到邮件发送对象为:&quot; + mailSender); mailUtils = new MailUtils(mailSender); String code = mailUtils.sendCode(email, userName, password); session.setAttribute(email + &quot;_code&quot;, code); return &quot;success&quot;; } public String sendCode(String email,String userName,String password){ int code = (int) ((Math.random() * 9 + 1) * 100000); logger.info(&quot;开始发送复杂邮件...&quot;); logger.info(&quot;mailSender对象为:&quot;+mailSender); MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage); try { helper.setSubject(&quot;莫提网盘-邮箱验证&quot;); helper.setText(&quot;&lt;h2 &gt;莫提网盘-简洁、优雅、免费&lt;/h2&gt;&quot; + &quot;&lt;h3&gt;用户注册-邮箱验证&lt;h3/&gt;&quot; + &quot;您现在正在注册莫提网盘账号&lt;br&gt;&quot; + &quot;验证码: &lt;span style=&#39;color : red&#39;&gt;&quot;+code+&quot;&lt;/span&gt;&lt;br&gt;&quot; + &quot;用户名 :&quot;+userName+ &quot;&lt;br&gt;密码 :&quot;+password+ &quot;&lt;hr&gt;&quot;+ &quot;&lt;h5 style=&#39;color : red&#39;&gt;如果并非本人操作,请忽略本邮件&lt;/h5&gt;&quot;,true); //helper.setFrom(&quot;你需要修改此处为你的QQ邮箱&quot;); helper.setFrom(&quot;707772743@qq.com&quot;); helper.setTo(email); } catch (MessagingException e) { e.printStackTrace(); } logger.info(&quot;mimeMessage对象为:&quot;+mimeMessage); mailSender.send(mimeMessage); return String.valueOf(code); } 后端生成验证码，生成的验证码，通过session属性返回给页面，通过邮件服务发送给注册邮箱，前端进行验证码比对. 注册 @PostMapping(&quot;/register&quot;) public String register(User user, String code, Map&lt;String, Object&gt; map) { String uCode = (String) session.getAttribute(user.getEmail() + &quot;_code&quot;); if (!code.equals(uCode)) { map.put(&quot;errorMsg&quot;, &quot;验证码错误&quot;); return &quot;index&quot;; } // 用户名去空格 user.setUserName(user.getUserName().trim()); user.setImagePath(&quot;https://p.qpic.cn/qqconnect/0/app_101851241_1582451550/100?max-age=2592000&amp;t=0&quot;); user.setRegisterTime(new Date()); user.setRole(1); if (userService.insert(user)) { FileStore store = FileStore.builder().userId(user.getUserId()).currentSize(0).build(); fileStoreService.addFileStore(store); user.setFileStoreId(store.getFileStoreId()); userService.update(user); logger.info(&quot;注册用户成功！当前注册用户&quot; + user); logger.info(&quot;注册仓库成功！当前注册仓库&quot; + store); } else { map.put(&quot;errorMsg&quot;, &quot;服务器发生错误，注册失败&quot;); return &quot;index&quot;; } session.removeAttribute(user.getEmail() + &quot;_code&quot;); session.setAttribute(&quot;loginUser&quot;, user); return &quot;redirect:/index&quot;; } 创建用户用户信息 创建该用户对应的仓库信息，并将用户信息与仓库信息关联起来。 1.2 登录 @PostMapping(&quot;/login&quot;) public String login(User user, Map&lt;String, Object&gt; map) { User userByEmail = userService.getUserByEmail(user.getEmail()); if (userByEmail != null &amp;&amp; userByEmail.getPassword().equals(user.getPassword())) { session.setAttribute(&quot;loginUser&quot;, userByEmail); logger.info(&quot;登录成功！&quot;+userByEmail); return &quot;redirect:/index&quot;; }else{ User user1 = userService.getUserByEmail(user.getEmail()); String errorMsg = user1 == null ? &quot;该邮箱尚未注册&quot; : &quot;密码错误&quot;; logger.info(&quot;登录失败！请确认邮箱和密码是否正确！&quot;); //登录失败，将失败信息返回前端渲染 map.put(&quot;errorMsg&quot;, errorMsg); return &quot;index&quot;; } 2. 文件操作2.1 文件上传2.1.1 easyUploader.js 工具GitHub 地址 https://github.com/funnyque/easyUpload.js 用法 参照GitHub 仓库README.md &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;示例&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/upload-file.css&quot;&gt; &lt;style&gt; html * { margin: 0; padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;uploader&quot;&gt;&lt;/div&gt; &lt;script src=&quot;js/easyUploader.jq.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var uploader = easyUploader({ id: &quot;uploader&quot;, accept: &#39;&#39;,//任何格式文件都支持 action: &#39;uploadFile&#39;, dataFormat: &#39;formData&#39;, headers:{ id:0 //这里是写的request的headers参数，后端可以获取这个数据 }, maxCount: 10, maxSize: 1024, multiple: true, data: null, beforeUpload: function(file, data, args) { /* dataFormat为formData时配置发送数据的方式 */ data.append(&#39;token&#39;, &#39;387126b0-7b3e-4a2a-86ad-ae5c5edd0ae6TT&#39;); data.append(&#39;otherKey&#39;, &#39;otherValue&#39;); /* dataFormat为base64时配置发送数据的方式 */ // data.base = file.base; // data.token = &#39;387126b0-7b3e-4a2a-86ad-ae5c5edd0ae6TT&#39;; // data.otherKey = &#39;otherValue&#39;; }, onChange: function(fileList) { /* input选中时触发 */ document.body.onbeforeunload = function() { window.event.returnValue = &quot;确认离开？&quot;; } }, onRemove: function(removedFiles, files) { console.log(&#39;onRemove&#39;, removedFiles); }, onSuccess: function(res) { var code = res[&quot;code&quot;]; console.log(code); if (code == 499){ alert(&quot;可能因为你的违规操作，您暂时无法上传文件！&quot;); } if (code == 501){ alert(&quot;当前目录存在同名文件，请删除后再试！&quot;); } if (code == 502){ alert(&quot;文件名不符合规范，支持【汉字,字符,数字,下划线,英文句号,横线】&quot;); } if (code == 503){ alert(&quot;仓库容量不足，上传失败！&quot;); } if (code == 504){ alert(&quot;服务器出错了！&quot;); } document.body.onbeforeunload = function () { window.event.returnValue = &quot;确认离开？&quot;; } }, onError: function(err) { console.log(&#39;onError&#39;, err); }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.1.2 后端接收数据 @PostMapping(&quot;/uploadFile&quot;) @ResponseBody public Map&lt;String, Object&gt; uploadFile(@RequestParam(&quot;file&quot;) MultipartFile files) { //1. 判断当前用户的文件仓库权限是否满足 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (fileStoreService.getFileStoreByUserId(loginUser.getUserId()).getPermission() != 0){ logger.error(&quot;用户没有上传文件的权限!上传失败...&quot;); map.put(&quot;code&quot;, 499); return map; } //2. 判断当前上传文件夹是否有同名文件 FileStore store = fileStoreService.getFileStoreByUserId(loginUser.getUserId()); //前端传过来的folderId Integer folderId = Integer.valueOf(request.getHeader(&quot;id&quot;)); //file.getOriginalFilename()是上传时的文件名 String name = files.getOriginalFilename().replaceAll(&quot; &quot;,&quot;&quot;); //获取当前目录下的所有文件，用来判断是否已经存在 List&lt;MyFile&gt; myFiles = null; if (folderId == 0){ //当前目录为根目录 myFiles = myFileService.getRootFilesByFileStoreId(loginUser.getFileStoreId()); }else { //当前目录为其他目录 myFiles = myFileService.getFilesByParentFolderId(folderId); } for (int i = 0; i &lt; myFiles.size(); i++) { if ((myFiles.get(i).getMyFileName()+myFiles.get(i).getPostfix()).equals(name)){ logger.error(&quot;当前文件已存在!上传失败...&quot;); map.put(&quot;code&quot;, 501); return map; } } //3. 检查文件名并定义存储路径 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateStr = format.format(new Date()); // userId/date/folderId String path = loginUser.getUserId()+&quot;/&quot;+dateStr +&quot;/&quot;+folderId; if (!checkTarget(name)){ logger.error(&quot;上传失败!文件名不符合规范...&quot;); map.put(&quot;code&quot;, 502); return map; } //4. 检查仓库size //toIntExact()方法从指定的long参数返回int值 Integer sizeInt = Math.toIntExact(files.getSize() / 1024); //是否仓库放不下该文件 if(store.getCurrentSize()+sizeInt &gt; store.getMaxSize()){ logger.error(&quot;上传失败!仓库已满。&quot;); map.put(&quot;code&quot;, 503); return map; } //5. 文件信息整理(名字，类型，大小) //处理文件大小 String size = String.valueOf(files.getSize()/1024.0); int indexDot = size.lastIndexOf(&quot;.&quot;); size = size.substring(0,indexDot); int index = name.lastIndexOf(&quot;.&quot;); String tempName = name; String postfix = &quot;&quot;; int type = 4; if (index!=-1){ tempName = name.substring(index); name = name.substring(0,index); //获得文件类型 type = getType(tempName.toLowerCase()); postfix = tempName.toLowerCase(); } //6. 提交到文件FTP服务器 try { //提交到FTP服务器 boolean b = FtpUtil.uploadFile(&quot;/&quot;+path, name + postfix, files.getInputStream()); if (b){ //上传成功 logger.info(&quot;文件上传成功!&quot;+files.getOriginalFilename()); //向数据库文件表写入数据 myFileService.addFileByFileStoreId( MyFile.builder() .myFileName(name).fileStoreId(loginUser.getFileStoreId()).myFilePath(path) .downloadTime(0).uploadTime(new Date()).parentFolderId(folderId). size(Integer.valueOf(size)).type(type).postfix(postfix).build()); //更新仓库表的当前大小 fileStoreService.addSize(store.getFileStoreId(),Integer.valueOf(size)); try { //不懂为何要睡5s Thread.sleep(5000); map.put(&quot;code&quot;, 200); } catch (InterruptedException e) { e.printStackTrace(); } }else{ logger.error(&quot;文件上传失败!&quot;+files.getOriginalFilename()); map.put(&quot;code&quot;, 504); } } catch (IOException e) { e.printStackTrace(); } return map; } 2.2 文件下载通过前端传过来的文件id去查询文件信息，再通过ftp下载 @GetMapping(&quot;/downloadFile&quot;) public String downloadFile(@RequestParam Integer fId){ if (fileStoreService.getFileStoreByUserId(loginUser.getUserId()).getPermission() == 2){ logger.error(&quot;用户没有下载文件的权限!下载失败...&quot;); return &quot;redirect:/error401Page&quot;; } //获取文件信息 MyFile myFile = myFileService.getFileByFileId(fId); String remotePath = myFile.getMyFilePath(); String fileName = myFile.getMyFileName()+myFile.getPostfix(); try { //去FTP上拉取 OutputStream os = new BufferedOutputStream(response.getOutputStream()); response.setCharacterEncoding(&quot;utf-8&quot;); // 设置返回类型 response.setContentType(&quot;multipart/form-data&quot;); // 文件名转码一下，不然会出现中文乱码//Content-Disposition客户端的弹出对话框，对应的文件名 (中文字符需要转一下编码) response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;)); boolean flag = FtpUtil.downloadFile(&quot;/&quot; + remotePath, fileName, os); if (flag) { myFileService.updateFile( MyFile.builder().myFileId(myFile.getMyFileId()).downloadTime(myFile.getDownloadTime() + 1).build()); os.flush(); os.close(); logger.info(&quot;文件下载成功!&quot; + myFile); } } catch (Exception e) { logger.info(&quot;yukino文件下载失败!&quot; + myFile); e.printStackTrace(); } return &quot;success&quot;; } public static boolean downloadFile(String remotePath, String fileName, OutputStream outputStream) { boolean result = false; //add by yukino remotePath = BASEPATH + remotePath; try { remotePath = new String(remotePath.getBytes(&quot;GBK&quot;),&quot;iso-8859-1&quot;); fileName = new String(fileName.getBytes(&quot;GBK&quot;),&quot;iso-8859-1&quot;); //初始化FTP客户端 if (!initFtpClient()){ return result; }; // 转移到FTP服务器目录 //ftp.changeWorkingDirectory(remotePath); ftp.changeWorkingDirectory(remotePath); ftp.enterLocalPassiveMode(); FTPFile[] fs = ftp.listFiles(); for (FTPFile ff : fs) { if (ff.getName().equals(fileName)) { ftp.enterLocalPassiveMode(); ftp.retrieveFile(remotePath+&quot;/&quot;+fileName,outputStream); result = true; } } ftp.logout(); } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return result; } 2.3 删除文件 @GetMapping(&quot;/deleteFile&quot;) public String deleteFile(@RequestParam Integer fId,Integer folder){ //获得文件信息 MyFile myFile = myFileService.getFileByFileId(fId); String remotePath = myFile.getMyFilePath(); String fileName = myFile.getMyFileName()+myFile.getPostfix(); //从FTP文件服务器上删除文件 boolean b = FtpUtil.deleteFile(&quot;/&quot;+remotePath, fileName); if (b){ //删除成功,返回空间 fileStoreService.subSize(myFile.getFileStoreId(),Integer.valueOf(myFile.getSize())); //删除文件表对应的数据 myFileService.deleteByFileId(fId); } logger.info(&quot;删除文件成功!&quot;+myFile); return &quot;redirect:/files?fId=&quot;+folder; } public static boolean deleteFile( String remotePath,String fileName){ boolean flag = false; remotePath = BASEPATH + remotePath; try { remotePath = new String(remotePath.getBytes(&quot;GBK&quot;),&quot;iso-8859-1&quot;); fileName = new String(fileName.getBytes(&quot;GBK&quot;),&quot;iso-8859-1&quot;); if (!initFtpClient()){ return flag; }; // 转移到FTP服务器目录 ftp.changeWorkingDirectory(remotePath); ftp.enterLocalPassiveMode(); FTPFile[] fs = ftp.listFiles(); for (FTPFile ff : fs) { if (&quot;&quot;.equals(fileName)){ return flag; } if (ff.getName().equals(fileName)){ String filePath = remotePath + &quot;/&quot; +fileName; ftp.deleteFile(filePath); flag = true; } } ftp.logout(); } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return flag; } 2.4 重命名文件 @PostMapping(&quot;/updateFileName&quot;) public String updateFileName(MyFile file,Map&lt;String, Object&gt; map) { MyFile myFile = myFileService.getFileByFileId(file.getMyFileId()); if (myFile != null){ String oldName = myFile.getMyFileName(); String newName = file.getMyFileName(); if (!oldName.equals(newName)){ boolean b = FtpUtil.reNameFile(myFile.getMyFilePath() + &quot;/&quot; + oldName+myFile.getPostfix(), myFile.getMyFilePath() + &quot;/&quot; + newName+myFile.getPostfix()); if (b){ Integer integer = myFileService.updateFile( MyFile.builder().myFileId(myFile.getMyFileId()).myFileName(newName).build()); if (integer == 1){ logger.info(&quot;修改文件名成功!原文件名:&quot;+oldName+&quot; 新文件名:&quot;+newName); }else{ logger.error(&quot;修改文件名失败!原文件名:&quot;+oldName+&quot; 新文件名:&quot;+newName); } } } } return &quot;redirect:/files?fId=&quot;+myFile.getParentFolderId(); } public static boolean reNameFile( String oldAllName,String newAllName){ boolean flag = false; try { oldAllName = new String(oldAllName.getBytes(&quot;GBK&quot;),&quot;iso-8859-1&quot;); newAllName = new String(newAllName.getBytes(&quot;GBK&quot;),&quot;iso-8859-1&quot;); if (!initFtpClient()){ return flag; }; ftp.enterLocalPassiveMode(); ftp.rename(oldAllName,newAllName); flag = true; ftp.logout(); } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return flag; } } 2.5 生成二维码 @GetMapping(&quot;getQrCode&quot;) @ResponseBody public Map&lt;String,Object&gt; getQrCode(@RequestParam Integer id,@RequestParam String url){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;imgPath&quot;,&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2654852821,3851565636&amp;fm=26&amp;gp=0.jpg&quot;); if (id != null){ MyFile file = myFileService.getFileByFileId(id); if (file != null){ try { //getRealPath是部署到Tomcat服务器上的项目文件夹下的路径，不是源代码的路径,是虚拟路径，但是依然可以访问 //private/var/folders/6p/73llqwqx1_xg39j8pm5fjd9m0000gn/T/tomcat-docbase.145091729584971266.8080/user_img/ String path = request.getSession().getServletContext().getRealPath(&quot;/user_img/&quot;); url = url+&quot;/file/share?t=&quot;+ UUID.randomUUID().toString().substring(0,10) +&quot;&amp;f=&quot;+file.getMyFileId()+&quot;&amp;p=&quot;+file.getUploadTime().getTime()+&quot;&quot;+file.getSize()+&quot;&amp;flag=1&quot;; File targetFile = new File(path, &quot;&quot;); if (!targetFile.exists()) { targetFile.mkdirs(); } File f = new File(path, id + &quot;.jpg&quot;); if (!f.exists()){ //文件不存在,开始生成二维码并保存文件 OutputStream os = new FileOutputStream(f); QRCodeUtil.encode(url, &quot;/static/img/logo.png&quot;, os, true); os.close(); } map.put(&quot;imgPath&quot;,&quot;user_img/&quot;+id+&quot;.jpg&quot;); map.put(&quot;url&quot;,url); } catch (Exception e) { e.printStackTrace(); } } } return map; } 2.6 分享文件 @GetMapping(&quot;/file/share&quot;) public String shareFile(Integer f,String p,String t,Integer flag){ String fileNameTemp = &quot;&quot;; String remotePath = &quot;&quot;; String fileName = &quot;&quot;; Integer times = 0; if (flag == null || f == null || p == null || t == null){ logger.info(&quot;下载分享文件失败，参数错误&quot;); return &quot;redirect:/error400Page&quot;; } if(flag == 1){ //获取文件信息 MyFile myFile = myFileService.getFileByFileId(f); if (myFile == null){ return &quot;redirect:/error404Page&quot;; } String pwd = myFile.getUploadTime().getTime()+&quot;&quot;+myFile.getSize(); if (!pwd.equals(p)){ return &quot;redirect:/error400Page&quot;; } remotePath = myFile.getMyFilePath(); fileName = myFile.getMyFileName()+myFile.getPostfix(); }else if(flag == 2){ TempFile tempFile = tempFileService.queryById(f); if (tempFile == null){ return &quot;redirect:/error404Page&quot;; } Long test = tempFile.getUploadTime().getTime(); String pwd = tempFile.getSize(); if (!pwd.equals(p)){ return &quot;redirect:/error400Page&quot;; } remotePath = tempFile.getFilePath(); fileName = tempFile.getFileName(); }else { return &quot;redirect:/error400Page&quot;; } fileNameTemp = fileName; try { //解决下载文件时 中文文件名乱码问题 boolean isMSIE = isMSBrowser(request); if (isMSIE) { //IE浏览器的乱码问题解决 fileNameTemp = URLEncoder.encode(fileNameTemp, &quot;UTF-8&quot;); } else { //万能乱码问题解决 fileNameTemp = new String(fileNameTemp.getBytes(&quot;UTF-8&quot;), &quot;ISO-8859-1&quot;); } //去FTP上拉取 OutputStream os = new BufferedOutputStream(response.getOutputStream()); response.setCharacterEncoding(&quot;utf-8&quot;); // 设置返回类型 response.setContentType(&quot;multipart/form-data&quot;); // 文件名转码一下，不然会出现中文乱码 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileNameTemp); if (FtpUtil.downloadFile(&quot;/&quot; + remotePath, fileName, os)) { myFileService.updateFile( MyFile.builder().myFileId(f).downloadTime(times + 1).build()); os.flush(); os.close(); logger.info(&quot;文件下载成功!&quot;); } } catch (Exception e) { e.printStackTrace(); } return &quot;success&quot;; } 3. 文件夹操作3.1 文件夹重命名 @PostMapping(&quot;/updateFolder&quot;) public String updateFolder(FileFolder folder,Map&lt;String, Object&gt; map) { //获得文件夹的数据库信息 FileFolder fileFolder = fileFolderService.getFileFolderByFileFolderId(folder.getFileFolderId()); fileFolder.setFileFolderName(folder.getFileFolderName()); //获得当前目录下的所有文件夹,用于检查文件夹是否已经存在 List&lt;FileFolder&gt; fileFolders = fileFolderService.getFileFolderByParentFolderId(fileFolder.getParentFolderId()); for (int i = 0; i &lt; fileFolders.size(); i++) { FileFolder folder1 = fileFolders.get(i); if (folder1.getFileFolderName().equals(folder.getFileFolderName()) &amp;&amp; folder1.getFileFolderId() != folder.getFileFolderId()){ logger.info(&quot;重命名文件夹失败!文件夹已存在...&quot;); return &quot;redirect:/files?error=2&amp;fId=&quot;+fileFolder.getParentFolderId(); } } //向数据库写入数据 Integer integer = fileFolderService.updateFileFolderById(fileFolder); logger.info(&quot;重命名文件夹成功!&quot;+folder); return &quot;redirect:/files?fId=&quot;+fileFolder.getParentFolderId(); } 3.2 清空并删除文件夹 public void deleteFolderF(FileFolder folder){ //获得当前文件夹下的所有子文件夹 List&lt;FileFolder&gt; folders = fileFolderService.getFileFolderByParentFolderId(folder.getFileFolderId()); //删除当前文件夹的所有的文件 List&lt;MyFile&gt; files = myFileService.getFilesByParentFolderId(folder.getFileFolderId()); if (files.size()!=0){ for (int i = 0; i &lt; files.size(); i++) { Integer fileId = files.get(i).getMyFileId(); boolean b = FtpUtil.deleteFile(&quot;/&quot;+files.get(i).getMyFilePath(), files.get(i).getMyFileName() + files.get(i).getPostfix()); if (b){ myFileService.deleteByFileId(fileId); fileStoreService.subSize(folder.getFileStoreId(),Integer.valueOf(files.get(i).getSize())); } } } if (folders.size()!=0){ for (int i = 0; i &lt; folders.size(); i++) { deleteFolderF(folders.get(i)); } } fileFolderService.deleteFileFolderById(folder.getFileFolderId()); } 3.3 添加文件夹 @PostMapping(&quot;/addFolder&quot;) public String addFolder(FileFolder folder,Map&lt;String, Object&gt; map) { //设置文件夹信息 folder.setFileStoreId(loginUser.getFileStoreId()); folder.setTime(new Date()); //获得当前目录下的所有文件夹,检查当前文件夹是否已经存在 List&lt;FileFolder&gt; fileFolders = null; if (folder.getParentFolderId() == 0){ //向用户根目录添加文件夹 fileFolders = fileFolderService.getRootFoldersByFileStoreId(loginUser.getFileStoreId()); }else{ //向用户的其他目录添加文件夹 fileFolders = fileFolderService.getFileFolderByParentFolderId(folder.getParentFolderId()); } for (int i = 0; i &lt; fileFolders.size(); i++) { FileFolder fileFolder = fileFolders.get(i); if (fileFolder.getFileFolderName().equals(folder.getFileFolderName())){ logger.info(&quot;添加文件夹失败!文件夹已存在...&quot;); return &quot;redirect:/files?error=1&amp;fId=&quot;+folder.getParentFolderId(); } } //向数据库写入数据 Integer integer = fileFolderService.addFileFolder(folder); logger.info(&quot;添加文件夹成功!&quot;+folder); return &quot;redirect:/files?fId=&quot;+folder.getParentFolderId(); } 4. 管理员操作4.1 前往用户管理界面 @GetMapping(&quot;/manages-users&quot;) public String manageUsers(Map&lt;String,Object&gt; map,Integer cur){ if (loginUser.getRole() == 1){ //用于无访问权限 logger.error(&quot;当前登录用户：&quot;+loginUser.getUserName()+&quot;无管理员权限！&quot;); return &quot;redirect:/error401Page&quot;; } //获取全部的用户 Integer usersCount = userService.getUsersCount(); //获取当前查询的页数，如果为空，默认为0 cur = (cur == null || cur&lt;0)?0:cur; //获得统计信息 FileStoreStatistics statistics = myFileService.getCountStatistics(loginUser.getFileStoreId()); //分页获得20个用户信息 Page&lt;Object&gt; page = PageHelper.startPage(cur, 20); List&lt;UserToShow&gt; users = userService.getUsers(); map.put(&quot;statistics&quot;, statistics); map.put(&quot;users&quot;, users); map.put(&quot;page&quot;, page); map.put(&quot;usersCount&quot;, usersCount); logger.info(&quot;用户管理域的内容：&quot;+map); return &quot;admin/manage-users&quot;; } 4.2 修改用户的权限和最大容量 @GetMapping(&quot;/updateStoreInfo&quot;) @ResponseBody public String updateStoreInfo(Integer uId,Integer pre,Integer size){ Integer integer = fileStoreService.updatePermission(uId, pre, size*1024); if (integer == 1) { //更新成功，返回200状态码 logger.info(&quot;修改用户&quot;+userService.queryById(uId).getUserName()+&quot;：的权限和仓库大小成功！&quot;); return &quot;200&quot;; }else { //更新失败，返回500状态码 logger.error(&quot;修改用户&quot;+userService.queryById(uId).getUserName()+&quot;：的权限和仓库大小失败！&quot;); return &quot;500&quot;; } } 4.3 删除用户 @GetMapping(&quot;/deleteUser&quot;) public String deleteUser(Integer uId,Integer cur){ cur = (cur == null || cur &lt; 0)?1:cur; User user = userService.queryById(uId); FileStore fileStore = fileStoreService.getFileStoreByUserId(uId); List&lt;FileFolder&gt; folders = fileFolderService.getRootFoldersByFileStoreId(fileStore.getFileStoreId()); //迭代删除文件夹 for (FileFolder f:folders) { deleteFolderF(f); } List&lt;MyFile&gt; files = myFileService.getRootFilesByFileStoreId(fileStore.getFileStoreId()); //删除该用户仓库根目录下的所有文件 for (MyFile f:files) { String remotePath = f.getMyFilePath(); String fileName = f.getMyFileName()+f.getPostfix(); //从FTP文件服务器上删除文件 boolean b = FtpUtil.deleteFile(&quot;/&quot;+remotePath, fileName); if (b){ //删除成功,返回空间 fileStoreService.subSize(f.getFileStoreId(),Integer.valueOf(f.getSize())); //删除文件表对应的数据 myFileService.deleteByFileId(f.getMyFileId()); } logger.info(&quot;删除文件成功!&quot;+f); } if (FtpUtil.deleteFolder(&quot;/&quot; + uId)){ logger.info(&quot;清空FTP上该用户的文件成功&quot;); }else { logger.error(&quot;清空FTP上该用户的文件失败&quot;); } userService.deleteById(uId); fileStoreService.deleteById(fileStore.getFileStoreId()); return &quot;redirect:/manages-users?cur=&quot;+cur; } public void deleteFolderF(FileFolder folder){ //获得当前文件夹下的所有子文件夹 List&lt;FileFolder&gt; folders = fileFolderService.getFileFolderByParentFolderId(folder.getFileFolderId()); //删除当前文件夹的所有的文件 List&lt;MyFile&gt; files = myFileService.getFilesByParentFolderId(folder.getFileFolderId()); if (files.size()!=0){ for (int i = 0; i &lt; files.size(); i++) { Integer fileId = files.get(i).getMyFileId(); boolean b = FtpUtil.deleteFile(&quot;/&quot;+files.get(i).getMyFilePath(), files.get(i).getMyFileName() + files.get(i).getPostfix()); if (b){ myFileService.deleteByFileId(fileId); fileStoreService.subSize(folder.getFileStoreId(),Integer.valueOf(files.get(i).getSize())); } } } if (folders.size()!=0){ for (int i = 0; i &lt; folders.size(); i++) { deleteFolderF(folders.get(i)); } } fileFolderService.deleteFileFolderById(folder.getFileFolderId()); } } 6. 其他通用配置6.1 注册视图控制器@Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/temp-file&quot;).setViewName(&quot;temp-file&quot;); registry.addViewController(&quot;/error400Page&quot;).setViewName(&quot;error/400&quot;); registry.addViewController(&quot;/error401Page&quot;).setViewName(&quot;error/401&quot;); registry.addViewController(&quot;/error404Page&quot;).setViewName(&quot;error/404&quot;); registry.addViewController(&quot;/error500Page&quot;).setViewName(&quot;error/500&quot;); } } 6.2 注册登录拦截器public class LoginHandlerInterceptor implements HandlerInterceptor { /** * 在目标方式执行之前执行 * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;); if (loginUser==null){ //未登录,返回登录页面 response.sendRedirect(&quot;/moti-cloud/&quot;); return false; }else { //已登录,放行 return true; } } } @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;) .excludePathPatterns( &quot;/&quot;,&quot;/temp-file&quot;,&quot;/error400Page&quot;,&quot;/error401Page&quot;,&quot;/error404Page&quot;,&quot;/error500Page&quot;,&quot;/uploadTempFile&quot;,&quot;/admin&quot;,&quot;/sendCode&quot;,&quot;/loginByQQ&quot;,&quot;/login&quot;,&quot;/register&quot;,&quot;/file/share&quot;,&quot;/connection&quot;, &quot;/asserts/**&quot;,&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png &quot;, &quot;/**/*.jpg&quot; ,&quot;/**/*.jpeg&quot;,&quot;/**/*.gif&quot;, &quot;/**/fonts/*&quot;, &quot;/**/*.svg&quot;); } } 6.3 配置错误界面@Configuration public class MvcConfig implements ErrorPageRegistrar{ @Override public void registerErrorPages(ErrorPageRegistry registry) { ErrorPage error400Page = new ErrorPage(HttpStatus.BAD_REQUEST, &quot;/error400Page&quot;); ErrorPage error401Page = new ErrorPage(HttpStatus.UNAUTHORIZED, &quot;/error401Page&quot;); ErrorPage error404Page = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/error404Page&quot;); ErrorPage error500Page = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/error500Page&quot;); registry.addErrorPages(error400Page,error401Page,error404Page,error500Page); } } 6.4 配置上传最大文件@Configuration public class MvcConfig implements WebMvcConfigurer, ErrorPageRegistrar { @Bean public MultipartConfigElement multipartConfigElement() { MultipartConfigFactory factory = new MultipartConfigFactory(); //文件最大 factory.setMaxFileSize(DataSize.parse(&quot;1024000KB&quot;)); /// 设置总上传数据总大小 factory.setMaxRequestSize(DataSize.parse(&quot;1024000KB&quot;)); return factory.createMultipartConfig(); } } //应该上面的设置对MultipartFile生效 public Map&lt;String, Object&gt; uploadFile(@RequestParam(&quot;file&quot;) MultipartFile files)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"cloud","slug":"cloud","permalink":"/tags/cloud/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ubuntu搭建FTP服务器","slug":"技术/FTP服务器","date":"2021-01-18T17:20:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2021/01/19/技术/FTP服务器/","link":"","permalink":"/2021/01/19/技术/FTP服务器/","excerpt":"","text":"Ubuntu 安装 VSFTPD 实现 FTP功能 安装VSFTPD sudo apt-get install vsftpd service vsftpd start # 启动vsftpd服务 新建用户uftp，并设置密码 sudo adduser userftp #之后的登录用户就是这个了 # 输入对应内容 Retype new UNIX password: passwd: password updated successfully Changing the user information for userftp Enter the new value, or press ENTER for the default Full Name []: userftp Room Number []: 1 Work Phone []: 1 Home Phone []: 1 Other []: 1 Is the information correct? [Y/n] y yukino@yukino:/home$ 注意：之后userftp作为账户，输入的密码作为登录密码。/home/userftp 已创建好 修改配置文件 sudo vim /etc/vsftpd.conf # 加入以下代码 userlist_deny=NO userlist_enable=YES userlist_file=/etc/allowed_users seccomp_sandbox=NO local_root=/home/userftp/ local_enable=YES write_enable=YES utf8_filesystem=YES 创建允许访问的用户列表 sudo vim /etc/allowed_users # 加入以下代码 userftp 检查禁止访问名单 sudo vim /etc/ftpusers 重启服务器 sudo /etc/init.d/vsftpd restart 访问ftp ftp://192.168.245.130 注: ftp 默认端口 21","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"FTP","slug":"FTP","permalink":"/tags/FTP/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"码问社区知识点拆解(2)","slug":"技术/码问社区知识点拆解 - 2","date":"2021-01-17T17:00:00.000Z","updated":"2022-10-09T15:19:10.437Z","comments":true,"path":"2021/01/18/技术/码问社区知识点拆解 - 2/","link":"","permalink":"/2021/01/18/技术/码问社区知识点拆解 - 2/","excerpt":"","text":"1.Bootstrap 起步 Site: https://v3.bootcss.com/getting-started/ 下载静态资源文件 导入到idea项目 html导入静态资源 &lt;!DOCTYPE HTML&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;码匠社区&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; 引入导航栏代码 https://v3.bootcss.com/components/#navbar-default &lt;body&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;码匠社区&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;码匠社区&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;搜索问题&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;我 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;消息中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人资料&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;退出登登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/body&gt; 2. GitHub 三方登录2.0 原理 2.1 进入Github开发者 github首页 头像 Setting Developer settings OAnth Apps New OAuth App Authorization callback URL 栏是最重要的，这是github之后，通过此地址接收github返回的信息 创建完成 在OAuth App创建完成后，需要记住Client ID和Client secrets, 这是与github 交互的依据 2.2 根据github api 接口获取数据Github OAuth Document 2.2.1 Users are redirected to request their GitHub identity&lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=bffae17dcea7490afcb6&amp;redirect_uri=http://localhost:8887/callback&amp;scope=user&amp;state=1&quot;&gt;登录&lt;/a&gt; 2.2.2 Users are redirected back to your site by GitHub 通过OkHttp发送POST GET请求 okHttp &lt;!--okhttp--&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; 例子 发送POST请求到github api public String getAccessToken(AccessTokenDTO accessTokenDTO) { MediaType mediaType = MediaType.get(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(JSON.toJSONString(accessTokenDTO), mediaType); Request request = new Request.Builder() .url(&quot;https://github.com/login/oauth/access_token&quot;) .post(body) .build(); try (Response response = client.newCall(request).execute()) { String string = response.body().string(); String token = string.split(&quot;&amp;&quot;)[0].split(&quot;=&quot;)[1]; return token; } catch (Exception e) { log.error(&quot;getAccessToken error,{}&quot;, accessTokenDTO, e); } return null; } 2.2.3 Use the access token to access the API public GithubUser getUser(String accessToken) { OkHttpClient client = new OkHttpClient(); // Request request = new Request.Builder() // .url(&quot;https://api.github.com/user?access_token=&quot; + accessToken) // .build(); Request request = new Request.Builder() .url(&quot;https://api.github.com/user&quot;) .header(&quot;Authorization&quot;,&quot;token &quot;+accessToken) .build(); try { Response response = client.newCall(request).execute(); String string = response.body().string(); System.out.println(string); GithubUser githubUser = JSON.parseObject(string, GithubUser.class); return githubUser; } catch (Exception e) { log.error(&quot;getUser error,{}&quot;, accessToken, e); } return null; } 注意!!!! 代码中注释掉的三行，是以前(2019年上)将Token作为地址参数带入的。现在已经不采用，而是将参数作为请求头参数带入。我折腾了很久才发现 2.2.4 完成获取user信息@Controller public class AuthorizeController { @Resource private GithubProvider githubProvider; @Value(&quot;${github.client.id}&quot;) private String clientId; @Value(&quot;${github.client.secret}&quot;) private String clientSecret; @Value(&quot;${github.redirect.uri}&quot;) private String redirectUri; @GetMapping(&quot;/callback&quot;) public String callback(@RequestParam(name = &quot;code&quot;) String code, @RequestParam(name = &quot;state&quot;) String state, HttpServletResponse response) { AccessTokenDTO accessTokenDTO = new AccessTokenDTO(); accessTokenDTO.setClient_id(clientId); accessTokenDTO.setClient_secret(clientSecret); accessTokenDTO.setCode(code); accessTokenDTO.setRedirect_uri(redirectUri); accessTokenDTO.setState(state); String accessToken = githubProvider.getAccessToken(accessTokenDTO); GithubUser githubUser = githubProvider.getUser(accessToken); System.out.println(&quot;yukino===&quot; + githubUser); return &quot;index&quot;; } } 3. 整合mybatis3.1 依赖 &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 3.2 model(entity)@Data public class User { private Integer id; private String name; private String accountId; private String token; private Long gmtCreate; private Long gmtModified; } 3.3 mapper@Mapper public interface UserMapper { @Insert(&quot;insert into user(name, account_id, token, gmt_create, gmt_modified) values(#{name}, #{accountId}, #{token}, #{gmtCreate}, #{gmtModified}) &quot;) public void insert(User user); @Select(&quot;select * from user where token=#{token}&quot;) User findByToken(@Param(&quot;token&quot;) String token); } 3.4 controller@Controller public class IndexController { @Resource private UserMapper userMapper; @GetMapping(&quot;/&quot;) public String index(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); if (cookies == null ) { return &quot;index&quot;; } for (Cookie cookie : cookies) { if (cookie.getName().equals(&quot;token&quot;)) { String token = cookie.getValue(); User user = userMapper.findByToken(token); if (user != null) { request.getSession().setAttribute(&quot;user&quot;, user); } break; } } return &quot;index&quot;; } } @Controller public class AuthorizeController { @Resource private GithubProvider githubProvider; @Value(&quot;${github.client.id}&quot;) private String clientId; @Value(&quot;${github.client.secret}&quot;) private String clientSecret; @Value(&quot;${github.redirect.uri}&quot;) private String redirectUri; @Resource UserMapper userMapper; @GetMapping(&quot;/callback&quot;) public String callback(@RequestParam(name = &quot;code&quot;) String code, @RequestParam(name = &quot;state&quot;) String state, HttpServletRequest request, HttpServletResponse response) { AccessTokenDTO accessTokenDTO = new AccessTokenDTO(); accessTokenDTO.setClient_id(clientId); accessTokenDTO.setClient_secret(clientSecret); accessTokenDTO.setCode(code); accessTokenDTO.setRedirect_uri(redirectUri); accessTokenDTO.setState(state); String accessToken = githubProvider.getAccessToken(accessTokenDTO); GithubUser githubUser = githubProvider.getUser(accessToken); if (githubUser != null) { User user = new User(); String token = UUID.randomUUID().toString(); user.setToken(token); user.setName(githubUser.getName()); user.setAccountId(String.valueOf(githubUser.getId())); user.setGmtCreate(System.currentTimeMillis()); user.setGmtModified(user.getGmtCreate()); userMapper.insert(user); response.addCookie(new Cookie(&quot;token&quot;, token)); request.getSession().setAttribute(&quot;user&quot;, githubUser); return &quot;redirect:/&quot;; } else { return &quot;redirect:/&quot;; } } } 4. 利用BootStrap 搭建前端界面4.1 栅格系统栅格系统 Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None （自动） 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 最大列（column）宽 自动 ~62px ~81px ~97px 槽（gutter）宽 30px （每列左右均有 15px） 可嵌套 是 偏移（Offsets） 是 列排序 是 &lt;div class=&quot;col-lg-9 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;/div&gt; 大屏幕 大桌面显示器 (≥1200px) : col-lg-9 占用窗口9格 中等屏幕 桌面显示器 (≥992px) : col-md-12 占用窗口12格 (即全部) 小屏幕 平板 (≥768px) : col-md-12 占用窗口12格 (即全部) 超小屏幕 手机 (&lt;768px) : col-md-12 占用窗口12格 (即全部) 4.2 组件组件 4.3 全局样式全局样式 4.4 举例&lt;!DOCTYPE HTML&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;码匠社区&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/community.css&quot;&gt; &lt;script src=&quot;js/bootstrap.min.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;码匠社区&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;码匠社区&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;搜索问题&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li th:if=&quot;${session.user == null}&quot;&gt; &lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=bffae17dcea7490afcb6&amp;redirect_uri=http://localhost:8887/callback&amp;scope=user&amp;state=1&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dropdown&quot; th:if=&quot;${session.user != null}&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; &lt;span th:text=&quot;${session.user.getName()}&quot;&gt;&lt;/span&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;消息中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人资料&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;退出登登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;div class=&quot;container-fluid main&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-9 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;h2&gt;&lt;span class=&quot;glyphicon glyphicon-align-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;发起&lt;/h2&gt; &lt;hr&gt; &lt;form action=&quot;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;问题标题(简明扼要)：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; name=&quot;title&quot; placeholder=&quot;问题标题.....&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;description&quot;&gt;问题补充 (必填，请参照右侧提示):&lt;/label&gt; &lt;textarea name=&quot;description&quot; id=&quot;description&quot; class=&quot;form-control&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;添加标签：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;tag&quot; name=&quot;tag&quot; placeholder=&quot;输入标签，以，号隔开&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-publish&quot;&gt;发布&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;h3&gt;问题发起指南&lt;/h3&gt; • 问题标题: 请用精简的语言描述您发布的问题，不超过25字 &lt;br&gt; • 问题补充: 详细补充您的问题内容，并确保问题描述清晰直观, 并提供一些相关的资料&lt;br&gt; • 选择标签: 选择一个或者多个合适的标签，用逗号隔开，每个标签不超过10个字&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 5. 分页5.1 直接实现分页5.1.1 实体类@Data public class PaginationDTO { private List&lt;QuestionDTO&gt; questions;//文章 private boolean showPrevious;//上一页 private boolean showFirstPage;//首页 private boolean showNext;//下一页 private boolean showEndPage;//尾页 private Integer page;//当前页 private List&lt;Integer&gt; pages = new ArrayList&lt;&gt;();//当前分页栏显示的页码集合 private Integer totalPage;// /** * * @param totalCount 问题总数 * @param page 地址栏的当前页数 * @param size 每一页的问题数量 */ public void setPagination(Integer totalCount, Integer page, Integer size) { totalPage = (totalCount % size == 0) ? (totalCount / size) : (totalCount / size + 1); if (page &lt; 1) { page = 1; } if (page &gt; totalPage) { page = totalPage; } this.page = page; //计算当前页的分页栏显示的页码集合 pages.add(page); for (int i = 1;i &lt;= 3; i++) { if (page - i &gt; 0) { pages.add(0, page - i); } if (page + i &lt;= totalPage) { pages.add(page + i); } } //是否展示上一页标签 if (page == 1) { showFirstPage = false; } else { showFirstPage = true; } //是否展示下一页标签 if (page == totalPage) { showEndPage = false; } else { showEndPage = true; } //是否展示首页箭头，只要没包含第一页，就显示首页标签 if (pages.contains(1)) { showFirstPage = false; } else { showFirstPage = true; } //是否展示尾页箭头 if (pages.contains(totalPage)) { showEndPage = false; } else { showEndPage = true; } } } 5.1.2 mapper类@Mapper public interface QuestionMapper { @Insert(&quot;insert into question(title, description, gmt_create, gmt_modified, creator, tag) values (#{title}, #{description},#{gmtCreate}, #{gmtModified}, #{creator}, #{tag})&quot;) public void create(Question question); //分页查询 @Select(&quot;select * from question limit #{offset}, #{size}&quot;) List&lt;Question&gt; list(@Param(&quot;offset&quot;) Integer offset, @Param(&quot;size&quot;) Integer size); //question查询 @Select(&quot;select count(1) from question&quot;) Integer count(); } 5.1.3 Service类@Service public class QuestionService { @Resource QuestionMapper questionMapper; @Resource UserMapper userMapper; public PaginationDTO list(Integer page, Integer size) { PaginationDTO paginationDTO = new PaginationDTO(); Integer totalCount = questionMapper.count();//问题总数 paginationDTO.setPagination(totalCount, page, size); if (page &lt; 1) { page = 1; } if (page &gt; paginationDTO.getTotalPage()) { page = paginationDTO.getTotalPage(); } //offset = size * (page - 1) Integer offset = size * (page - 1); List&lt;Question&gt; questions = questionMapper.list(offset, size); List&lt;QuestionDTO&gt; questionDTOS = new ArrayList&lt;&gt;(); for (Question question : questions ) { User user = userMapper.findById(question.getCreator()); QuestionDTO questionDTO = new QuestionDTO(); //拷贝属性 //巧妙不使用外键的方法 BeanUtils.copyProperties(question, questionDTO); questionDTO.setUser(user); questionDTOS.add(questionDTO); } paginationDTO.setQuestions(questionDTOS); return paginationDTO; } } @Data public class QuestionDTO { private Integer id; private String title; private String description; private String tag; private Long gmtCreate; private Long gmtModified; private Integer creator; private Integer viewCount; private Integer commentCount; private Integer likeCount; private User user; } 5.1.4 Controller @Resource private QuestionService questionService; @GetMapping(&quot;/&quot;) public String index(HttpServletRequest request, Model model, @RequestParam(name = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer page, @RequestParam(name = &quot;size&quot;, defaultValue = &quot;2&quot;) Integer size) { Cookie[] cookies = request.getCookies(); if (cookies == null ) { return &quot;index&quot;; } for (Cookie cookie : cookies) { if (cookie.getName().equals(&quot;token&quot;)) { String token = cookie.getValue(); User user = userMapper.findByToken(token); if (user != null) { request.getSession().setAttribute(&quot;user&quot;, user); } break; } } PaginationDTO pagination = questionService.list(page, size); System.out.println(pagination.toString()); //model.addAttribute(&quot;questions&quot;, questionList); model.addAttribute(&quot;pagination&quot;, pagination); return &quot;index&quot;; } } 5.1.5 html &lt;div class=&quot;col-lg-9 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;h2&gt;&lt;span class=&quot;glyphicon glyphicon-list-alt&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;发起&lt;/h2&gt; &lt;hr&gt; &lt;div class=&quot;media&quot; th:each=&quot;question : ${pagination.getQuestions()}&quot;}&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img class=&quot;media-object img-rounded&quot; src=&quot;/img/2.jpg&quot; width=&quot;43px&quot; height=&quot;43px&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot; th:text=&quot;${question.getTitle()}&quot;&gt;&lt;/h4&gt; &lt;span th:text=&quot;${question.getDescription()}&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;span text-desc&gt;&lt;span th:text=&quot;${question.getCommentCount()}&quot;&gt;&lt;/span&gt;个回复 &lt;span th:text=&quot;${question.getViewCount()}&quot;&gt;&lt;/span&gt;31 次浏览 &lt;span th:text=&quot;${#dates.format(question.getGmtCreate(), &#39;dd MMM yyyy&#39;)}&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;div th:text=&quot;yukino+${pagination.isShowFirstPage()}&quot;&gt;&lt;/div&gt; &lt;li th:if=&quot;${pagination.isShowFirstPage()}&quot;&gt; &lt;a href=&quot;/?page=1&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li th:if=&quot;${pagination.isShowPrevious()}&quot;&gt; &lt;a href=&quot;@{/(page=${pagination.page - 1})}&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;lt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li th:each=&quot;page : ${pagination.getPages()}&quot; th:class=&quot;${pagination.getPage() == page} ? &#39;active&#39; : &#39;&#39;&quot;&gt; &lt;a th:href=&quot;@{/(page=${page})}&quot; th:text=&quot;${page}&quot; &gt; &lt;/a&gt; &lt;/li&gt; &lt;li th:if=&quot;${pagination.isShowNext()}&quot;&gt; &lt;a href=&quot;@{/(page=${pagination.page + 1})}&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li th:if=&quot;${pagination.isShowEndPage()}&quot;&gt; &lt;a href=&quot;@{/(page=${pagination.getTotalPage()})}&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; 5.2 pageHelper 分页5.2.1 分页失效1pageHelper版本低导致 pageInfo 数据不准确 &lt;!--pageHelper--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 当时 1.2.0 会失效，1.3.0 正常 5.2.2 分页失效2pageHelper逻辑复杂导致 pageInfo 数据不准确 @GetMapping(&quot;/&quot;) public String index(HttpServletRequest request, Model model, @RequestParam(name = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(name = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize) { Cookie[] cookies = request.getCookies(); if (cookies == null ) { return &quot;index&quot;; } for (Cookie cookie : cookies) { if (cookie.getName().equals(&quot;token&quot;)) { String token = cookie.getValue(); User user = userMapper.findByToken(token); if (user != null) { request.getSession().setAttribute(&quot;user&quot;, user); } break; } } PageHelper.startPage(1,5); /*这种写法有问题*/ List&lt;QuestionDTO&gt; list = questionService.selectQuestions(); PageInfo pageInfo = PageInfo.of(list); model.addAttribute(&quot;pagination&quot;, pageInfo); return &quot;index&quot;; } @Service public class QuestionService { @Resource QuestionMapper questionMapper; @Resource UserMapper userMapper; //获取所有的问题，添加了User类对象 public List&lt;QuestionDTO&gt; selectQuestions() { List&lt;QuestionDTO&gt; questionDTOS = new ArrayList&lt;&gt;(); List&lt;Question&gt; questions = questionMapper.selectAllQuestions(); for (Question question : questions) { QuestionDTO questionDTO = new QuestionDTO(); BeanUtils.copyProperties(question, questionDTO); User user = userMapper.findById(question.getCreator()); questionDTO.setUser(user); questionDTOS.add(questionDTO); } return questionDTOS; } } 以上这种写法，把pageInfo放在了controller层，service内数据复杂，使sql数据没有紧接着PageHelper.startPage(1,5); 解决方案是，将pageInfo放在service层，查询数据直接来自mapper层，在PageHelper.startPage(1,5);和sql`间无多余的逻辑，然后将pageInfo封装后，传给controller 5.2.3 下拉菜单分页 &lt;!--pageHelper--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; #分页插件 #pagehelper分页插件配置 pagehelper.helperDialect=mysql pagehelper.reasonable=true pagehelper.supportMethodsArguments=true pagehelper.params=count=countSql @Service public class QuestionService { @Resource QuestionMapper questionMapper; @Resource UserMapper userMapper; //获取所有的问题，添加了User类对象 public Map&lt;String, Object&gt; selectQuestions(Integer pageNum, Integer pageSize) { Map&lt;String, Object&gt; allData = new HashMap(); List&lt;QuestionDTO&gt; questionDTOS = new ArrayList&lt;&gt;(); //获取pageInfo PageHelper.startPage(pageNum,pageSize); List&lt;Question&gt; questions = questionMapper.selectAllQuestions(); PageInfo pageInfo = PageInfo.of(questions); //获取questionDTO for (Question question : questions) { QuestionDTO questionDTO = new QuestionDTO(); BeanUtils.copyProperties(question, questionDTO); questionDTOS.add(questionDTO); } allData.put(&quot;questionDTOS&quot;, questionDTOS); allData.put(&quot;pageInfo&quot;, pageInfo); return allData; } } @RequestMapping(&quot;/&quot;) public String index(HttpServletRequest request, Model model, @RequestParam(name = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(name = &quot;pageSize&quot;, defaultValue = &quot;5&quot;) Integer pageSize) { Cookie[] cookies = request.getCookies(); if (cookies == null ) { return &quot;index&quot;; } for (Cookie cookie : cookies) { if (cookie.getName().equals(&quot;token&quot;)) { String token = cookie.getValue(); User user = userMapper.findByToken(token); if (user != null) { request.getSession().setAttribute(&quot;user&quot;, user); } break; } } Map&lt;String, Object&gt; allData = questionService.selectQuestions(pageNum, pageSize); List&lt;QuestionDTO&gt; questionDTOS = (List&lt;QuestionDTO&gt;) allData.get(&quot;questionDTOS&quot;); PageInfo pageInfo = (PageInfo) allData.get(&quot;pageInfo&quot;); model.addAttribute(&quot;questionDTOS&quot;, questionDTOS); model.addAttribute(&quot;pageInfo&quot;, pageInfo); return &quot;index1&quot;; } &lt;div class=&quot;media&quot; th:each=&quot;questionDTO : ${questionDTOS}&quot;}&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img class=&quot;media-object img-rounded&quot; src=&quot;/img/2.jpg&quot; width=&quot;43px&quot; height=&quot;43px&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot; th:text=&quot;${questionDTO.getTitle()}&quot;&gt;&lt;/h4&gt; &lt;span th:text=&quot;${questionDTO.getDescription()}&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;span text-desc&gt;&lt;span th:text=&quot;${questionDTO.getCommentCount()}&quot;&gt;&lt;/span&gt;个回复 &lt;span th:text=&quot;${questionDTO.getViewCount()}&quot;&gt;&lt;/span&gt;31 次浏览 &lt;span th:text=&quot;${#dates.format(questionDTO.getGmtCreate(), &#39;dd MMM yyyy&#39;)}&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;select class=&quot;poi-pager__item_middle_select poi-form__control form-control&quot; onchange=&quot;location.href=this.value&quot;&gt; &lt;option selected=&quot;&quot; th:selected=&quot;${pageInfo.getPageNum() == index}&quot; th:each=&quot;index : ${#numbers.sequence(1,pageInfo.pages)}&quot; th:value=&quot;@{/(page=${index})}&quot;&gt; 第 [(${index})] 页 &lt;/option&gt; &lt;/select&gt; 注意 onchange=&quot;location.href=this.value&quot;是读取option的value，然后跳转，在重新加载整个页面 6. 集成 markdown editor 官网 http://editor.md.ipandao.com/ 用法 下载github 源码 将源码导入项目 如图，将源码导入editormd文件夹 页面引入 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;editormd/css/editormd.css&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test-editor&quot;&gt; &lt;textarea style=&quot;display:none;&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;editormd/editormd.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { var editor = editormd(&quot;test-editor&quot;, { width : &quot;100%&quot;, height : &quot;1500px&quot;, path : &quot;editormd/lib/&quot; }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果图","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"开源","slug":"开源","permalink":"/tags/开源/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"码问社区源码解析(1)","slug":"技术/码问社区源码解析 - 1","date":"2021-01-17T16:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2021/01/18/技术/码问社区源码解析 - 1/","link":"","permalink":"/2021/01/18/技术/码问社区源码解析 - 1/","excerpt":"","text":"1.问题发布1.1 前端界面 1.2 文章发布 @PostMapping(&quot;/publish&quot;) public String doPublish( @RequestParam(value = &quot;title&quot;, required = false) String title, @RequestParam(value = &quot;description&quot;, required = false) String description, @RequestParam(value = &quot;tag&quot;, required = false) String tag, @RequestParam(value = &quot;id&quot;, required = false) Long id, HttpServletRequest request, Model model) { //用于下面&quot;标题不能为空&quot;等异常状态时，正常内容的回显 model.addAttribute(&quot;title&quot;, title); model.addAttribute(&quot;description&quot;, description); model.addAttribute(&quot;tag&quot;, tag); model.addAttribute(&quot;tags&quot;, TagCache.get()); if (StringUtils.isBlank(title)) { model.addAttribute(&quot;error&quot;, &quot;标题不能为空&quot;); return &quot;publish&quot;; } if (StringUtils.isBlank(description)) { model.addAttribute(&quot;error&quot;, &quot;问题补充不能为空&quot;); return &quot;publish&quot;; } if (StringUtils.isBlank(tag)) { model.addAttribute(&quot;error&quot;, &quot;标签不能为空&quot;); return &quot;publish&quot;; } //获取无效标签 String invalid = TagCache.filterInvalid(tag); if (StringUtils.isNotBlank(invalid)) { model.addAttribute(&quot;error&quot;, &quot;输入非法标签:&quot; + invalid); return &quot;publish&quot;; } User user = (User) request.getSession().getAttribute(&quot;user&quot;); if (user == null) { model.addAttribute(&quot;error&quot;, &quot;用户未登录&quot;); return &quot;publish&quot;; } Question question = new Question(); question.setTitle(title); question.setDescription(description); question.setTag(tag); question.setCreator(user.getId()); question.setId(id); questionService.createOrUpdate(question); return &quot;redirect:/&quot;; } 注意 文章新建时，接收的参数id为空(tag:mashiro) 需要对”标题”(null)，”内容”(null)，”标签”(null or invalid)，”用户”(login)的异常状态进行处理(tag:mashiro) 1.2.1 标签管理public class TagCache { public static List&lt;TagDTO&gt; get() { List&lt;TagDTO&gt; tagDTOS = new ArrayList&lt;&gt;(); TagDTO program = new TagDTO(); program.setCategoryName(&quot;开发语言&quot;); program.setTags(Arrays.asList(&quot;javascript&quot;, &quot;php&quot;, &quot;css&quot;, &quot;html&quot;, &quot;html5&quot;, &quot;java&quot;, &quot;node.js&quot;, &quot;python&quot;, &quot;c++&quot;, &quot;c&quot;, &quot;golang&quot;, &quot;objective-c&quot;, &quot;typescript&quot;, &quot;shell&quot;, &quot;swift&quot;, &quot;c#&quot;, &quot;sass&quot;, &quot;ruby&quot;, &quot;bash&quot;, &quot;less&quot;, &quot;asp.net&quot;, &quot;lua&quot;, &quot;scala&quot;, &quot;coffeescript&quot;, &quot;actionscript&quot;, &quot;rust&quot;, &quot;erlang&quot;, &quot;perl&quot;)); tagDTOS.add(program); TagDTO framework = new TagDTO(); framework.setCategoryName(&quot;平台框架&quot;); framework.setTags(Arrays.asList(&quot;laravel&quot;, &quot;spring&quot;, &quot;express&quot;, &quot;django&quot;, &quot;flask&quot;, &quot;yii&quot;, &quot;ruby-on-rails&quot;, &quot;tornado&quot;, &quot;koa&quot;, &quot;struts&quot;)); tagDTOS.add(framework); TagDTO server = new TagDTO(); server.setCategoryName(&quot;服务器&quot;); server.setTags(Arrays.asList(&quot;linux&quot;, &quot;nginx&quot;, &quot;docker&quot;, &quot;apache&quot;, &quot;ubuntu&quot;, &quot;centos&quot;, &quot;缓存 tomcat&quot;, &quot;负载均衡&quot;, &quot;unix&quot;, &quot;hadoop&quot;, &quot;windows-server&quot;)); tagDTOS.add(server); TagDTO db = new TagDTO(); db.setCategoryName(&quot;数据库&quot;); db.setTags(Arrays.asList(&quot;mysql&quot;, &quot;redis&quot;, &quot;mongodb&quot;, &quot;sql&quot;, &quot;oracle&quot;, &quot;nosql memcached&quot;, &quot;sqlserver&quot;, &quot;postgresql&quot;, &quot;sqlite&quot;)); tagDTOS.add(db); TagDTO tool = new TagDTO(); tool.setCategoryName(&quot;开发工具&quot;); tool.setTags(Arrays.asList(&quot;git&quot;, &quot;github&quot;, &quot;visual-studio-code&quot;, &quot;vim&quot;, &quot;sublime-text&quot;, &quot;xcode intellij-idea&quot;, &quot;eclipse&quot;, &quot;maven&quot;, &quot;ide&quot;, &quot;svn&quot;, &quot;visual-studio&quot;, &quot;atom emacs&quot;, &quot;textmate&quot;, &quot;hg&quot;)); tagDTOS.add(tool); return tagDTOS; } public static String filterInvalid(String tags) { String[] split = StringUtils.split(tags, &quot;,&quot;); List&lt;TagDTO&gt; tagDTOS = get(); //获取所有标签 72个 List&lt;String&gt; tagList = tagDTOS.stream().flatMap(tag -&gt; tag.getTags().stream()).collect(Collectors.toList()); String invalid = Arrays.stream(split).filter(t -&gt; StringUtils.isBlank(t) || !tagList.contains(t)).collect(Collectors.joining(&quot;,&quot;)); return invalid; } public static void main(String[] args) { int i = (5 - 1) &gt;&gt;&gt; 1; System.out.println(i); } } 注意 filterInvalid函数的表达方式可以重点掌握(tag:mashiro) 1.3 文章修改文章修改与文章新建区别在于，前者会在form标签中增加隐藏域标签，后端接受函数是相同的 &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;6&quot;&gt; public void createOrUpdate(Question question) { if (question.getId() == null) { // 创建 question.setGmtCreate(System.currentTimeMillis()); question.setGmtModified(question.getGmtCreate()); question.setViewCount(0); question.setLikeCount(0); question.setCommentCount(0); questionMapper.insert(question); } else { // 更新 Question dbQuestion = questionMapper.selectByPrimaryKey(question.getId()); //判断是否修改文章是否在数据库对应 if (dbQuestion == null) { throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND); } //判断修改操作人与文章创建人是否一致 if (dbQuestion.getCreator().longValue() != question.getCreator().longValue()) { throw new CustomizeException(CustomizeErrorCode.INVALID_OPERATION); } Question updateQuestion = new Question(); updateQuestion.setGmtModified(System.currentTimeMillis()); updateQuestion.setTitle(question.getTitle()); updateQuestion.setDescription(question.getDescription()); updateQuestion.setTag(question.getTag()); // 通过 example 自定义 sql操作 QuestionExample example = new QuestionExample(); example.createCriteria() .andIdEqualTo(question.getId()); int updated = questionMapper.updateByExampleSelective(updateQuestion, example); if (updated != 1) { throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND); } } } 注意 必须判断修改文章是否在数据库内(tag:mashiro) 必须判断文章修改者与文章创建者是否是同一人(tag:mashiro) 2. 回复功能2.1 前端界面文章回复(1级评论) 评论回复(2级评论) 2.2 controller 接受 ajax数据传输类型 @Data public class CommentCreateDTO { private Long parentId; private String content; private Integer type; } 接受ajax数据，并存入数据库 @ResponseBody @RequestMapping(value = &quot;/comment&quot;, method = RequestMethod.POST) //@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)； public Object post(@RequestBody CommentCreateDTO commentCreateDTO, HttpServletRequest request) { User user = (User) request.getSession().getAttribute(&quot;user&quot;); if (user == null) { return ResultDTO.errorOf(CustomizeErrorCode.NO_LOGIN); } //StringUtils.isBlank //1.是否为null //2.是否为&quot;&quot; //3.&quot; &quot;,字符串中间有空格，制表符、换行符、换页符和回车 if (commentCreateDTO == null || StringUtils.isBlank(commentCreateDTO.getContent())) { return ResultDTO.errorOf(CustomizeErrorCode.CONTENT_IS_EMPTY); } Comment comment = new Comment(); //注意：1级评论时，ParentId为 question id，当2级评论时，ParentId 为 上一级评论Id comment.setParentId(commentCreateDTO.getParentId()); comment.setContent(commentCreateDTO.getContent()); comment.setType(commentCreateDTO.getType()); comment.setGmtModified(System.currentTimeMillis()); comment.setGmtCreate(System.currentTimeMillis()); comment.setCommentator(user.getId()); comment.setLikeCount(0L); commentService.insert(comment, user); return ResultDTO.okOf(); } 注意 异常处理 : 用户(login)、内容(null) (tag:mashiro) ParentId 可以为问题 id，也可以为 评论id。这取决于 type 的值(tag:mashiro) 评论insert详情，需要判断是1级评论还是2级评论 @Service public class CommentService { //@Transactional //https://zhuanlan.zhihu.com/p/47362056 //1. 一般标记在public 方法 //2. @Transactional(rollbackFor=Exception.class)，如果方法抛出异常，就会回滚，数据库里面的数据也会回滚。 //3. 在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚 @Transactional public void insert(Comment comment, User commentator) { //评论需要在某个问题或者某个评论下进行 if (comment.getParentId() == null || comment.getParentId() == 0) { throw new CustomizeException(CustomizeErrorCode.TARGET_PARAM_NOT_FOUND); } // type == 1 : 1级评论(对问题评论) type == 2 : 2级评论(对评论进行评论) if (comment.getType() == null || !CommentTypeEnum.isExist(comment.getType())) { throw new CustomizeException(CustomizeErrorCode.TYPE_PARAM_WRONG); } if (comment.getType() == CommentTypeEnum.COMMENT.getType()) { // 2级评论，回复评论 //查找父评论 Comment dbComment = commentMapper.selectByPrimaryKey(comment.getParentId()); if (dbComment == null) { throw new CustomizeException(CustomizeErrorCode.COMMENT_NOT_FOUND); } // 查找父评论对应的问题 Question question = questionMapper.selectByPrimaryKey(dbComment.getParentId()); if (question == null) { throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND); } commentMapper.insert(comment); // 增加评论数 Comment parentComment = new Comment(); parentComment.setId(comment.getParentId()); parentComment.setCommentCount(1); commentExtMapper.incCommentCount(parentComment); // 创建通知 createNotify(comment, dbComment.getCommentator(), commentator.getName(), question.getTitle(), NotificationTypeEnum.REPLY_COMMENT, question.getId()); } else { // 1级评论，回复问题 Question question = questionMapper.selectByPrimaryKey(comment.getParentId()); if (question == null) { throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND); } //此评论的评论数初始化为0 comment.setCommentCount(0); commentMapper.insert(comment); question.setCommentCount(1); //question评论数自增 questionExtMapper.incCommentCount(question); // 创建通知 createNotify(comment, question.getCreator(), commentator.getName(), question.getTitle(), NotificationTypeEnum.REPLY_QUESTION, question.getId()); } } } 注意 关注@Transactional的用法(tag:mashiro) 注意异常处理意识 public enum CommentTypeEnum { //枚举了QUESTION和COMMENT，type类型是公有的。1,2作为构造参数，赋值给type QUESTION(1), COMMENT(2); private Integer type; public Integer getType() { return type; } CommentTypeEnum(Integer type) { this.type = type; } public static boolean isExist(Integer type) { //CommentTypeEnum.values() 代表全部枚举变量 //1. type = 1 name = &quot;QUESTION&quot; ordinal = 0 //2. type = 2 name = &quot;COMMENT&quot; ordinal = 1 for (CommentTypeEnum commentTypeEnum : CommentTypeEnum.values()) { if (commentTypeEnum.getType() == type) { return true; } } return false; } } question评论数自增 &lt;update id=&quot;incCommentCount&quot; parameterType=&quot;life.majiang.community.model.Question&quot;&gt; update QUESTION set COMMENT_COUNT = COMMENT_COUNT + #{commentCount,jdbcType=INTEGER} where id = #{id} &lt;/update&gt; 3. 首页问题排序3.1 前端页面 3.2 controller @GetMapping(&quot;/&quot;) public String index(Model model, @RequestParam(name = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer page, @RequestParam(name = &quot;size&quot;, defaultValue = &quot;10&quot;) Integer size, @RequestParam(name = &quot;search&quot;, required = false) String search, @RequestParam(name = &quot;tag&quot;, required = false) String tag, @RequestParam(name = &quot;sort&quot;, required = false) String sort) { //对热词进行检索，对结果进行排序后的结果 PaginationDTO pagination = questionService.list(search, tag, sort, page, size); //获取热门标签 List&lt;String&gt; tags = hotTagCache.getHots(); model.addAttribute(&quot;pagination&quot;, pagination); model.addAttribute(&quot;search&quot;, search); model.addAttribute(&quot;tag&quot;, tag); model.addAttribute(&quot;tags&quot;, tags); model.addAttribute(&quot;sort&quot;, sort); return &quot;index&quot;; } 3.3 service /** * * @param search 搜索栏内容 * @param tag 首页热门标签 * @param sort 问题排序最新、30天最热、7天最热、最热、消灭零回复(sort = new sort = hot30 sort = hot7 sort = hot sort = no) * @param page * @param size * @return */ public PaginationDTO list(String search, String tag, String sort, Integer page, Integer size) { //搜索内容预处理 if (StringUtils.isNotBlank(search)) { String[] tags = StringUtils.split(search, &quot; &quot;); search = Arrays .stream(tags) .filter(StringUtils::isNotBlank) .map(t -&gt; t.replace(&quot;+&quot;, &quot;&quot;).replace(&quot;*&quot;, &quot;&quot;).replace(&quot;?&quot;, &quot;&quot;)) .filter(StringUtils::isNotBlank) .collect(Collectors.joining(&quot;|&quot;)); } PaginationDTO paginationDTO = new PaginationDTO(); Integer totalPage; QuestionQueryDTO questionQueryDTO = new QuestionQueryDTO(); //search=mashiro|hanser，| 方便 sql 正则查询 questionQueryDTO.setSearch(search); if (StringUtils.isNotBlank(tag)) { tag = tag.replace(&quot;+&quot;, &quot;&quot;).replace(&quot;*&quot;, &quot;&quot;).replace(&quot;?&quot;, &quot;&quot;); questionQueryDTO.setTag(tag); } //设置 sort for (SortEnum sortEnum : SortEnum.values()) { if (sortEnum.name().toLowerCase().equals(sort)) { questionQueryDTO.setSort(sort); if (sortEnum == SortEnum.HOT7) { //7天前的时间戳 questionQueryDTO.setTime(System.currentTimeMillis() - 1000L * 60 * 60 * 24 * 7); } if (sortEnum == SortEnum.HOT30) { //30天前的时间戳 questionQueryDTO.setTime(System.currentTimeMillis() - 1000L * 60 * 60 * 24 * 30); } break; } } //设置查询分页数据 Integer totalCount = questionExtMapper.countBySearch(questionQueryDTO); if (totalCount % size == 0) { totalPage = totalCount / size; } else { totalPage = totalCount / size + 1; } if (page &lt; 1) { page = 1; } if (page &gt; totalPage) { page = totalPage; } paginationDTO.setPagination(totalPage, page); Integer offset = page &lt; 1 ? 0 : size * (page - 1); questionQueryDTO.setSize(size); questionQueryDTO.setPage(offset); //questionQueryDTO 数据准备完成，进行查询 List&lt;Question&gt; questions = questionExtMapper.selectBySearch(questionQueryDTO); List&lt;QuestionDTO&gt; questionDTOList = new ArrayList&lt;&gt;(); for (Question question : questions) { User user = userMapper.selectByPrimaryKey(question.getCreator()); QuestionDTO questionDTO = new QuestionDTO(); BeanUtils.copyProperties(question, questionDTO); questionDTO.setUser(user); questionDTOList.add(questionDTO); } paginationDTO.setData(questionDTOList); return paginationDTO; } 3.4 Dao &lt;select id=&quot;selectBySearch&quot; parameterType=&quot;life.majiang.community.dto.QuestionQueryDTO&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from QUESTION &lt;where&gt; &lt;if test=&quot;search != null and search != &#39;&#39;&quot;&gt; and title regexp #{search} &lt;/if&gt; &lt;if test=&quot;tag != null and tag != &#39;&#39;&quot;&gt; and tag regexp #{tag} &lt;/if&gt; &lt;if test=&quot;sort != null and sort != &#39;&#39; and sort == &#39;no&#39;&quot;&gt; and comment_count = 0 &lt;/if&gt; &lt;if test=&quot;time != null and time != &#39;&#39;&quot;&gt; and gmt_create &gt; #{time} &lt;/if&gt; &lt;/where&gt; &lt;if test=&quot;sort == null or sort == &#39;&#39;&quot;&gt; order by gmt_create desc &lt;/if&gt; &lt;if test=&quot;sort != null and sort != &#39;&#39; and sort == &#39;new&#39;&quot;&gt; order by gmt_create desc &lt;/if&gt; &lt;if test=&quot;sort != null and sort != &#39;&#39; and sort == &#39;no&#39;&quot;&gt; order by gmt_create desc &lt;/if&gt; &lt;if test=&quot;sort != null and sort != &#39;&#39; and (sort == &#39;hot&#39; || sort == &#39;hot7&#39; || sort == &#39;hot30&#39;)&quot;&gt; order by comment_count desc &lt;/if&gt; limit #{page},#{size} &lt;/select&gt; 4. 热点tag(定时任务)@Component @Slf4j public class HotTagTasks { @Autowired private QuestionMapper questionMapper; @Autowired private HotTagCache hotTagCache; //定时任务 //fixedRate 固定时间执行 单位 ms @Scheduled(fixedRate = 1000 * 60 * 60 * 3) public void hotTagSchedule() { int offset = 0; int limit = 20; log.info(&quot;hotTagSchedule start {}&quot;, new Date()); List&lt;Question&gt; list = new ArrayList&lt;&gt;(); Map&lt;String, Integer&gt; priorities = new HashMap&lt;&gt;(); //根据评论数，计算每个tag的热度 while (offset == 0 || list.size() == limit) { list = questionMapper.selectByExampleWithRowbounds(new QuestionExample(), new RowBounds(offset, limit)); for (Question question : list) { //每个问题的tag是以逗号分割的 String[] tags = StringUtils.split(question.getTag(), &quot;,&quot;); for (String tag : tags) { Integer priority = priorities.get(tag); if (priority != null) { priorities.put(tag, priority + 5 + question.getCommentCount()); } else { priorities.put(tag, 5 + question.getCommentCount()); } } } offset += limit; } hotTagCache.updateTags(priorities); log.info(&quot;hotTagSchedule stop {}&quot;, new Date()); } } 注意 测出个人认为应该先查询所有的数据，将所有的tag 计算出 priority ，但是这个时间可能会很长(tag:mashiro) @Component @Data public class HotTagCache { private List&lt;String&gt; hots = new ArrayList&lt;&gt;(); public void updateTags(Map&lt;String, Integer&gt; tags) { int max = 10; //PriorityQueue 优先队列(小顶堆二叉树结构)保证每次取出的元素 PriorityQueue&lt;HotTagDTO&gt; priorityQueue = new PriorityQueue&lt;&gt;(max); tags.forEach((name, priority) -&gt; { HotTagDTO hotTagDTO = new HotTagDTO(); hotTagDTO.setName(name); hotTagDTO.setPriority(priority); if (priorityQueue.size() &lt; max) { //向小顶堆添加元素 priorityQueue.add(hotTagDTO); } else { //获取堆顶元素，元素值最小 HotTagDTO minHot = priorityQueue.peek(); if (hotTagDTO.compareTo(minHot) &gt; 0) { //删除堆顶元素,此处新元素大于堆顶元素，删除堆顶元素 priorityQueue.poll(); priorityQueue.add(hotTagDTO); } } }); List&lt;String&gt; sortedTags = new ArrayList&lt;&gt;(); HotTagDTO poll = priorityQueue.poll(); while (poll != null) { sortedTags.add(0, poll.getName()); poll = priorityQueue.poll(); } hots = sortedTags; } } 注意 保持PriorityQueue队列中，最多存在10个元素，且元素值时最大的10个，即热度最高的10个tag，使用PriorityQueue的原因是，由于是小顶堆的结构，一个新来的元素很快就能找到所属位置，如果使用List的话，每次都是遍历，时间复杂太高。(tag:mashiro) 5. 异常处理5.1 异常处理标准定义public interface ICustomizeErrorCode { String getMessage() ; Integer getCode(); } public enum CustomizeErrorCode implements ICustomizeErrorCode { //枚举类型 QUESTION_NOT_FOUND(2001, &quot;你找到问题不在了，要不要换个试试？&quot;), TARGET_PARAM_NOT_FOUND(2002, &quot;未选中任何问题或评论进行回复&quot;), NO_LOGIN(2003, &quot;当前操作需要登录，请登陆后重试&quot;), SYS_ERROR(2004, &quot;服务冒烟了，要不然你稍后再试试！！！&quot;), TYPE_PARAM_WRONG(2005, &quot;评论类型错误或不存在&quot;), COMMENT_NOT_FOUND(2006, &quot;回复的评论不存在了，要不要换个试试？&quot;), CONTENT_IS_EMPTY(2007, &quot;输入内容不能为空&quot;), READ_NOTIFICATION_FAIL(2008, &quot;兄弟你这是读别人的信息呢？&quot;), NOTIFICATION_NOT_FOUND(2009, &quot;消息莫非是不翼而飞了？&quot;), FILE_UPLOAD_FAIL(2010, &quot;图片上传失败&quot;), INVALID_INPUT(2011, &quot;非法输入&quot;), INVALID_OPERATION(2012, &quot;兄弟，是不是走错房间了？&quot;), ; @Override public String getMessage() { return message; } @Override public Integer getCode() { return code; } //成员变量 private Integer code; private String message; //枚举内的构造函数 CustomizeErrorCode(Integer code, String message) { this.message = message; this.code = code; } } public class CustomizeException extends RuntimeException {//继承运行时异常，可以手动抛出异常 private String message; private Integer code; // 构造函数参数为ICustomizeErrorCode public CustomizeException(ICustomizeErrorCode errorCode) { this.code = errorCode.getCode(); this.message = errorCode.getMessage(); } @Override public String getMessage() { return message; } public Integer getCode() { return code; } } throw new CustomizeException(CustomizeErrorCode.INVALID_INPUT);//手动抛出异常 5.2 @ControllerAdvice @ExceptionHandler@ControllerAdvice//注解定义全局异常处理类 @Slf4j public class CustomizeExceptionHandler { @ExceptionHandler(Exception.class)//捕获Exception类及其子类异常 ModelAndView handle(Throwable e, Model model, HttpServletRequest request, HttpServletResponse response) { String contentType = request.getContentType(); if (&quot;application/json&quot;.equals(contentType)) { ResultDTO resultDTO; // 返回 JSON if (e instanceof CustomizeException) { //异常是new CustomizeException 抛出来的 resultDTO = ResultDTO.errorOf((CustomizeException) e); } else { log.error(&quot;handle error&quot;, e); resultDTO = ResultDTO.errorOf(CustomizeErrorCode.SYS_ERROR); } try { response.setContentType(&quot;application/json&quot;); response.setStatus(200); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(JSON.toJSONString(resultDTO)); writer.close(); } catch (IOException ioe) { } return null; } else { // 错误页面跳转 if (e instanceof CustomizeException) { model.addAttribute(&quot;message&quot;, e.getMessage()); } else { log.error(&quot;handle error&quot;, e); model.addAttribute(&quot;message&quot;, CustomizeErrorCode.SYS_ERROR.getMessage()); } return new ModelAndView(&quot;error&quot;);//跳转到error.html } } } @ControllerAdvice + @ExceptionHandler捕获全局异常 throw new CustomizeException(CustomizeErrorCode.INVALID_INPUT);可以捕获类似抛出异常 @Data public class ResultDTO&lt;T&gt; { private Integer code; private String message; private T data; public static ResultDTO errorOf(Integer code, String message) { ResultDTO resultDTO = new ResultDTO(); resultDTO.setCode(code); resultDTO.setMessage(message); return resultDTO; } public static ResultDTO errorOf(CustomizeErrorCode errorCode) { return errorOf(errorCode.getCode(), errorCode.getMessage()); } public static ResultDTO errorOf(CustomizeException e) { return errorOf(e.getCode(), e.getMessage()); } public static ResultDTO okOf() { ResultDTO resultDTO = new ResultDTO(); resultDTO.setCode(200); resultDTO.setMessage(&quot;请求成功&quot;); return resultDTO; } public static &lt;T&gt; ResultDTO okOf(T t) { ResultDTO resultDTO = new ResultDTO(); resultDTO.setCode(200); resultDTO.setMessage(&quot;请求成功&quot;); resultDTO.setData(t); return resultDTO; } } 5.3 controller/* ${server.error.path:${error.path:/error}} 如果 server.error.path 未配置,则使用 ${error.path:/error} 如果 error.path 未配置,则使用 &quot;/error&quot; */ @Controller @RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;) public class CustomizeErrorController implements ErrorController { @Override public String getErrorPath() { return &quot;error&quot;; } @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)//设置返回的数据类型 public ModelAndView errorHtml(HttpServletRequest request, Model model) { HttpStatus status = getStatus(request); if (status.is4xxClientError()) { model.addAttribute(&quot;message&quot;, &quot;你这个请求错了吧，要不然换个姿势？&quot;); } if (status.is5xxServerError()) { model.addAttribute(&quot;message&quot;, &quot;服务冒烟了，要不然你稍后再试试！！！&quot;); } return new ModelAndView(&quot;error&quot;); } private HttpStatus getStatus(HttpServletRequest request) { Integer statusCode = (Integer) request .getAttribute(&quot;javax.servlet.error.status_code&quot;); if (statusCode == null) { return HttpStatus.INTERNAL_SERVER_ERROR; } try { return HttpStatus.valueOf(statusCode); } catch (Exception ex) { return HttpStatus.INTERNAL_SERVER_ERROR; } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"开源","slug":"开源","permalink":"/tags/开源/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java语法","slug":"技术/Java 语法","date":"2021-01-17T12:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2021/01/17/技术/Java 语法/","link":"","permalink":"/2021/01/17/技术/Java 语法/","excerpt":"","text":"1. stream() 使用 stream().map List&lt;Integer&gt; list = Arrays.asList(1,2,3,4); List&lt;Integer&gt; list2 = list.stream().map(l1 -&gt; l1 * 2).collect(Collectors.toList()); List&lt;String&gt; list3 = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;cc&quot;,&quot;dd&quot;); List&lt;String&gt; list4 = list3.stream().map(String::toUpperCase).collect(Collectors.toList()); List&lt;String&gt; list3 = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;cc&quot;,&quot;dd&quot;); //映射规则可以是一个函数 List&lt;String&gt; list4 = list3.stream().map(l1 -&gt; {return l1.toUpperCase();}).collect(Collectors.toList()); stream().map 表示将数组、列表等的元素按照一定规则进行映射 collect(Collectors.toList());表示将映射结果转换成列表 collect(Collectors.toSet());表述转换成集合，可以达到去重目的 stream().filter List&lt;Integer&gt; list = Arrays.asList(1,2,3,4); List&lt;Integer&gt; list1 = list.stream().filter(l1 -&gt; l1.intValue() &gt; 3).collect(Collectors.toList()); stream().filter 表示将数组、列表等的元素按照一定规则进行筛选,保留的是满足上面条件的 Collectors.toMap 实现list 转 map @Data @AllArgsConstructor class User { private Integer id; private String name; } List&lt;User&gt; list5 = Arrays.asList( new User(1, &quot;yukino&quot;), new User(2, &quot;mashiro&quot;), new User(3, &quot;yui&quot;) ); Map&lt;Integer, String&gt; collect = list5.stream().collect(Collectors.toMap(User::getId, User::getName)); Collectors.joining 实现字符串拼接 String[] name = {&quot;yukino*&quot;, &quot;mash?iro&quot;, &quot;yu+i&quot;}; Stream&lt;String&gt; stringStream = Stream.of(name); String collect = stringStream .map(t -&gt; t.replace(&quot;*&quot;, &quot;&quot;).replace(&quot;+&quot;, &quot;&quot;).replace(&quot;?&quot;, &quot;&quot;)) .collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;)); System.out.println(collect); [yukino,mashiro,yui] stream().flatMap 作用 列表中的元素含有列表成员，取出元素，再将元素成员列表的元素取出来，进行合并 @Data @AllArgsConstructor class TagDTO { private String categoryName; private List&lt;String&gt; tags; } public static void main(String[] args) { TagDTO tagDTO1 = new TagDTO(&quot;开发语言&quot;, Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;)); TagDTO tagDTO2 = new TagDTO(&quot;开发工具&quot;, Arrays.asList(&quot;IDEA&quot;, &quot;Tomcat&quot;)); List&lt;TagDTO&gt; tagDTOS = Arrays.asList(tagDTO1, tagDTO2); List&lt;String&gt; collect = tagDTOS.stream().flatMap(tag -&gt; tag.getTags().stream()).collect(Collectors.toList()); System.out.println(collect); } [Java, Python, C, IDEA, Tomcat] 2. Map foreach的使用Map&lt;String, String&gt; infoMap = new HashMap&lt;&gt;(); infoMap.put(&quot;name&quot;,&quot;yukino&quot;); infoMap.put(&quot;site&quot;,&quot;www.yukino.tech&quot;); infoMap.put(&quot;email&quot;, &quot;xxxx&quot;); infoMap.forEach((key,value) -&gt; { System.out.println(key + &quot;:&quot; + value); }); 3. PriorityQueuePriorityQueue，即优先队列，由小顶堆组成 @Data @AllArgsConstructor class HotTagDTO implements Comparable { private String name; private Integer priority; //此方法是元素比较大小的依据 @Override public int compareTo(Object o) { return this.getPriority() - ((HotTagDTO) o).getPriority(); } } public static void main(String[] args) { PriorityQueue&lt;HotTagDTO&gt; priorityQueue = new PriorityQueue&lt;&gt;(10); priorityQueue.add(new HotTagDTO(&quot;yukino&quot;, 1)); priorityQueue.add(new HotTagDTO(&quot;mashiro&quot;,2)); System.out.println(priorityQueue.peek().getName()); } add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。 element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个 remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。 remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"日积跬步","slug":"日积跬步","permalink":"/tags/日积跬步/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Docker","slug":"技术/Docker","date":"2021-01-17T11:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2021/01/17/技术/Docker/","link":"","permalink":"/2021/01/17/技术/Docker/","excerpt":"","text":"1. Docker 安装2. Docker 使用2.1 介绍 docker hello world docker run hello-world 查看镜像 docker images run 流程 Docker先在本地寻找镜像，如果本地有，则直接执行。若本地没有，则直接去run。若没有，则去Docker Hub上去下载到本地 2.2 docker 命令2.2.1 帮助命令docker version #显示 docker的版本信息 docker info #显示docker的系统信息,包括镜像和容器的数量 docker 命令 --help 2.2.2 文档2.2.3 镜像命令docker images 查看本地主机所有镜像 yukino@Yukinos-Mac-mini  ~  docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 12 months ago 13.3kB # 解释 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像 id CREATED 创建时间 SIZE 大小 # 可选项 -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don&#39;t truncate output -q, --quiet Only show image IDs docker search 搜索 yukino@Yukinos-Mac-mini  ~  docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 10369 [OK] mariadb MariaDB is a community-developed fork of MyS… 3842 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 757 [OK] percona Percona Server is a fork of the MySQL relati… 519 [OK] # 可选项 -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don&#39;t truncate output # 通过 start 进行过滤 --filter=STARS=3000 # 不小于3000 # docker search mysql --filter=STARS=3000 docker pull 下载 yukino@Yukinos-Mac-mini  ~  docker pull mysql Using default tag: latest #如果不写tag，默认就是 latest latest: Pulling from library/mysql 6ec7b7d162b2: Pull complete # 分层下载，docker image的核心 联合文件系统 fedd960d3481: Pull complete 7ab947313861: Pull complete 64f92f19e638: Pull complete 3e80b17bff96: Pull complete 014e976799f9: Pull complete 59ae84fee1b3: Pull complete ffe10de703ea: Pull complete 657af6d90c83: Pull complete 98bfb480322c: Pull complete 6aa3859c4789: Pull complete 1ed875d851ef: Pull complete Digest: sha256:78800e6d3f1b230e35275145e657b82c3fb02a27b2d8e76aac2f5e90c1c30873 #签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址 # 等价 docker pull mysql docker pull docker.io/library/mysql:latest #指定版本 docker pull mysql:5.7 yukino@Yukinos-Mac-mini  ~  docker pull mysql:5.7 5.7: Pulling from library/mysql 6ec7b7d162b2: Already exists fedd960d3481: Already exists 7ab947313861: Already exists 64f92f19e638: Already exists 3e80b17bff96: Already exists 014e976799f9: Already exists 59ae84fee1b3: Already exists 7d1da2a18e2e: Pull complete 301a28b700b9: Pull complete 529dc8dbeaf3: Pull complete bc9d021dc13f: Pull complete Digest: sha256:c3a567d3e3ad8b05dfce401ed08f0f6bf3f3b64cc17694979d5f2e5d78e10173 Status: Downloaded newer image for mysql:5.7 docker.io/library/mysql:5.7 yukino@Yukinos-Mac-mini  ~  docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7 f07dfa83b528 2 weeks ago 448MB mysql latest a347a5928046 2 weeks ago 545MB hello-world latest bf756fb1ae65 12 months ago 13.3kB docker rmi删除 yukino@Yukinos-Mac-mini  ~  docker rmi -f f07dfa83b #删除一个镜像 Untagged: mysql:5.7 Untagged: mysql@sha256:c3a567d3e3ad8b05dfce401ed08f0f6bf3f3b64cc17694979d5f2e5d78e10173 Deleted: sha256:f07dfa83b5283f486f1fa1628cb8b4a18a4d071a486708acc5c06243ca7f592a Deleted: sha256:1137660d239dd339c83697d1d5cc93542333aaf35c1fd90418f9c0d166c23487 Deleted: sha256:20c29fc0161bc3cc0addc48ab1aeb70f605a5529590fd32d01502d58d1c6dc10 Deleted: sha256:8615ae1ee613441540ee54a2c517eb0600a6c83667a79f7ca74acc9ffec4c9a4 Deleted: sha256:252efab3ecb7891820c5a340645044850d6edc7815c6588450d74b0a743424f4 yukino@Yukinos-Mac-mini  ~  docker rmi -f $(docker images -aq) #删除所有镜像 Untagged: mysql:latest Untagged: mysql@sha256:78800e6d3f1b230e35275145e657b82c3fb02a27b2d8e76aac2f5e90c1c30873 Deleted: sha256:a347a59280467629ae4d70ce555e3f96faca8ff2ff8c57cacc8184bebb681f66 Deleted: sha256:8c4db4ce0f63c9eec74a2e555bb7e2fa5e2de08389cbc747793aa30bc3ac04e1 Deleted: sha256:6179be2adc547662cd0ef2cb032b85809ac68923b7ab9c71e5a21b88bbe7f542 Deleted: sha256:17d702350e6aa7f240ca23090d24b059f5c324e292a77b5069225e76e0b51dd6 Deleted: sha256:5c5f95733957fd96300b5265d6b2df728415ed62e7b4b30eadd7d836d48187bf Deleted: sha256:fbf118fadaf5230c8df9a3b51c608393a8f3adb99c089ea2db253438efab1a0e Deleted: sha256:43b82d704a10e6d022fa3f31a5f827a00e339ee21dd2849a9b120ab82be9af71 Deleted: sha256:a4994702421d2b9a74c4f3810aa7ac09990e849905f23a1d8f358c826d58501f Deleted: sha256:36c598c7a6f90abf6d67cde4a58b0747bfbcc7441d3b782bdeea7cda8c9ad7b6 Deleted: sha256:86f598b4f8200bdd4ae752f916154e4e29d5b4c211bb124eb150b9957a3e0141 Deleted: sha256:9e979d97f92bf78a225c77c6b4ba74eb2e03efb95b19b69206cd17cee15a4b26 Deleted: sha256:aff48ce4678f78d83d7e9bfb9e88cd951c3da52da08779e99b6082edd1cc66f3 Deleted: sha256:87c8a1d8f54f3aa4e05569e8919397b65056aa71cdf48b7f061432c98475eee9 Untagged: hello-world:latest Untagged: hello-world@sha256:1a523af650137b8accdaed439c17d684df61ee4d74feac151b5b337bd29e7eec Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b 2.2.4 容器命令下载一个centos镜像来学习 docker pull centos 新建容器并启动 docker run [可选参数] image #参数说明 --name=“name” 容器名字 -d 后台运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器端口 -p 8080:8080 -p 主机端口:容器端口 -p ip:主机端口:容器端口 -p 容器端口 -P 随机指定端口 # 启动并进入容器 yukino@Yukinos-Mac-mini  ~  docker run -it centos /bin/sh sh-4.4# # 退出容器 exit 列出所有的运行的容器 yukino@Yukinos-Mac-mini  ~  docker ps #正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES yukino@Yukinos-Mac-mini  ~  docker ps -a # 列出当前正在运行游戏 + 历史运行过的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 58058be7aaee centos &quot;/bin/sh&quot; About a minute ago Exited (0) 11 seconds ago friendly_khorana d163d1d78b57 centos &quot;/bin/sh&quot; 2 minutes ago Exited (0) About a minute ago charming_curie 4a7f75643f52 centos &quot;/bin/zsh&quot; 3 minutes ago Created objective_ellis f8639e957394 centos &quot;/bin/sh&quot; 3 minutes ago Exited (0) 3 minutes ago reverent_wing 76a01cac119f bf756fb1ae65 &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago frosty_edison # 可选项 -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don&#39;t truncate output -q, --quiet Only display container IDs -s, --size Display total file sizes 容器退出 exit # 容器停止退出 cmd(中间那个键) + p + q #容器不停止退出 删除容器 docker rm 容器id #删除指定容器，不能删除正在运行的容器， -f 强制删除 docker rm -f $(docker ps -aq) #删除所有容器 docker ps -a -q|xargs docker rm -f #删除所有容器 启动和停止容器的操作 docker start 容器id # 启动容器 docker restart 容器id # 重启容器 docker stop 容器id # 停止容器 docker kill 容器id # 强制停止当前容器 2.2.5 常用其他命令后台启动容器 yukino@Yukinos-Mac-mini  ~  docker run -d centos # 后台启动容器 0ed9981b2b99a49d7a6badda06d6b5214adf7f4abd12e69b59a3740944c86da2 yukino@Yukinos-Mac-mini  ~  docker ps # 发现没有起来 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # docker 容器使用后台运行，必须要一个前台进程，docker发现没有应用，就会自动停止 # nginx 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 查看日志 # 自己编写一段shell脚本 yukino@Yukinos-Mac-mini  ~  docker run -d centos /bin/sh -c &quot;while true;do echo hello;sleep 1;done&quot; 7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859 # 查看容器 yukino@Yukinos-Mac-mini  ~  docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7e367211d5e0 centos &quot;/bin/sh -c &#39;while t…&quot; 6 seconds ago Up 5 seconds mystifying_ardinghelli # 查看log yukino@Yukinos-Mac-mini  ~  docker logs -tf --tail 10 7e367211d5e0 2021-01-11T16:03:59.195128830Z hello 2021-01-11T16:04:00.197724751Z hello 2021-01-11T16:04:01.200070913Z hello 2021-01-11T16:04:02.204645447Z hello 2021-01-11T16:04:03.209292239Z hello # 可选项 Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes) -n, --tail string Number of lines to show from the end of the logs (default &quot;all&quot;) -t, --timestamps Show timestamps --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes) 查看容器中的进程信息 yukino@Yukinos-Mac-mini  ~  docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7e367211d5e0 centos &quot;/bin/sh -c &#39;while t…&quot; 5 minutes ago Up 5 minutes mystifying_ardinghelli # 查看进程信息 yukino@Yukinos-Mac-mini  ~  docker top 7e367211d5e0 PID USER TIME COMMAND 3248 root 0:00 /bin/sh -c while true;do echo hello;sleep 1;done 3641 root 0:00 {sleep} /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像元数据 docker inspect 7e367211d5e0 [ { &quot;Id&quot;: &quot;7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859&quot;, &quot;Created&quot;: &quot;2021-01-11T16:03:29.779361521Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo hello;sleep 1;done&quot; ], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 3248, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-01-11T16:03:30.085701324Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; }, &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859/7e367211d5e06cf782c23ed36e8bd915e79c7d37290f340b08f49c121ac13859-json.log&quot;, &quot;Name&quot;: &quot;/mystifying_ardinghelli&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: { &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: { &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: {} }, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: {}, &quot;RestartPolicy&quot;: { &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 }, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] }, &quot;GraphDriver&quot;: { &quot;Data&quot;: { &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/acddf2185fe63f216521b671abaeca46264f46939e439026c4b0a6151da02c5d-init/diff:/var/lib/docker/overlay2/329520e3e0d88d8454fba204a80c88b7f6ef891bb8dbd6691761ac4d95c5177d/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/acddf2185fe63f216521b671abaeca46264f46939e439026c4b0a6151da02c5d/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/acddf2185fe63f216521b671abaeca46264f46939e439026c4b0a6151da02c5d/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/acddf2185fe63f216521b671abaeca46264f46939e439026c4b0a6151da02c5d/work&quot; }, &quot;Name&quot;: &quot;overlay2&quot; }, &quot;Mounts&quot;: [], &quot;Config&quot;: { &quot;Hostname&quot;: &quot;7e367211d5e0&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true;do echo hello;sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: { &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; } }, &quot;NetworkSettings&quot;: { &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;273cc9e3080fa62dc986a5c0b8da4ef8c86edaa2f7af92a241e388638c7647c6&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: {}, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/273cc9e3080f&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;d147d056858d03efcdb9ce0a1a14552873ebe1c87c55514523def2dc879b206b&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;7c3627e0ba0582a218c280f8fbb0bd6cca3d3325582b5cedd1b8b6410de986cd&quot;, &quot;EndpointID&quot;: &quot;d147d056858d03efcdb9ce0a1a14552873ebe1c87c55514523def2dc879b206b&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null } } } } ] 进入当前正在运行的容器 # 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 yukino@Yukinos-Mac-mini  ~  docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7e367211d5e0 centos &quot;/bin/sh -c &#39;while t…&quot; 13 minutes ago Up 13 minutes mystifying_ardinghelli # 方式1:以交互模式进入容器 yukino@Yukinos-Mac-mini  ~  docker exec -it 7e367211d5e0 /bin/bash [root@7e367211d5e0 /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 16:03 ? 00:00:00 /bin/sh -c while true;do echo hello;sleep 1;done root 864 0 0 16:17 pts/0 00:00:00 /bin/bash root 1023 1 0 16:20 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 root 1024 864 0 16:20 pts/0 00:00:00 ps -ef # 方式2: docker attach yukino@Yukinos-Mac-mini  ~  docker attach e367211d5e 正在执行当前的代码 # docker exec # 进入容器开启一个新的终端，可以在里面操作(常用) # docker attach # 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到主机上 docker cp f03fddef487a:/home/tmp.md . # 拷贝是一个手动过程，未来我们通过-V 卷的技术，可以实现自动同步 /home /home 2.2.6 docker 命令小结 2.2.7 docker tomcat启动# 官方使用 docker run -it --rm tomcat:9.0# 一般用来测试，用完就删除容易(镜像还在)，一般不这样用 # 下载启动 docker pull tomcat:9.0 #启动运行 docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0 #后台启动，宿主机端口映射3355映射到容器端口8080 # 发现浏览器访问 http://localhost:3355/ 出错。 #进入tomcat docker exec -it tomcat01 /bin/sh 进入 tomcat下的webapps，发现为空 # 拷贝内容，刷新浏览器访问 http://localhost:3355/，成功 cp -r webapps.dist/* webapps/ 2.2.8 可视化portainer docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 2.2.9 commit 镜像# 启动容器 docker run -it -p 8080:8080 tomcat:9.0 # 进入容器 docker exec -it d239c0637046 /bin/sh # 添加webapps应用 cp -r webapps.dist/* webapps/ # commit 成一个新镜像 yukino@Yukinos-Mac-mini  ~  docker commit -a=&quot;yukino&quot; -m=&quot;add webapps app&quot; d239c0637046 tomcat02:1.0 sha256:98532da3cc1bbd014972e720081c187023f2172f9caaced66e94cd2f5c48b85c yukino@Yukinos-Mac-mini  ~  docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 98532da3cc1b 5 seconds ago 653MB # 使用一个新镜像 docker run -it -p 8081:8080 tomcat02:1.0 3. 容器数据卷3.1 使用卷技术docker run -it -v 主机目录:容器目录 docker run -it -v /Users/yukino/Desktop/temp/test:/home centos /bin/sh # 查看挂载信息 docker inspect 5f48c7d36c11 &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/Users/yukino/Desktop/temp/test&quot;, &quot;Destination&quot;: &quot;/home&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; } ], 两个文件夹数据共享,将容器删除掉，数据依然能够保存 3.2 mysql# 官方测试代码 docker run --name some-mysql -v /my/own/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 --name 容器名 # docker run -d -p 3310:3306 -v /Users/yukino/Desktop/temp/mysql/conf:/etc/mysql/conf.d -v /Users/yukino/Desktop/temp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:8.0 3.3 具名和匿名挂载docker volume Commands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes # 查看所有volume docker volume ls # 匿名挂载 yukino@Yukinos-Mac-mini  ~/Desktop/temp/mysql/data  docker run -d -P --name nginx01 -v /etc/nginx nginx yukino@Yukinos-Mac-mini  ~/Desktop/temp/mysql/data  docker volume ls DRIVER VOLUME NAME local 3510004e6812e29dbbbda68b229b61e8cda715d573eef744bd470843014bea88 local 8388160e20f4753e11b20d159c0eca0eb8f269fdbe1e37274874bf0dc85871e9 # 匿名挂载挂载即 -v 只写了容器内的路径，没有写容器外的路径 # 具名挂载 -v 卷名:容器路径 yukino@Yukinos-Mac-mini  ~/Desktop/temp/mysql/data  docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx 9656638bbc24aabdfc5961eaa7824c508b6fb7e152c78ab16b7af50dcc3f7a92 yukino@Yukinos-Mac-mini  ~/Desktop/temp/mysql/data  docker volume ls DRIVER VOLUME NAME local 3510004e6812e29dbbbda68b229b61e8cda715d573eef744bd470843014bea88 local 8388160e20f4753e11b20d159c0eca0eb8f269fdbe1e37274874bf0dc85871e9 local juming-nginx # 通过卷名，查看卷信息 yukino@Yukinos-Mac-mini  ~/Desktop/temp/mysql/data  docker volume inspect juming-nginx [ { &quot;CreatedAt&quot;: &quot;2021-01-12T16:36:27Z&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, &quot;Name&quot;: &quot;juming-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; } ] 如何确定是具名还是匿名 -v 容器内路径 # 匿名 -v 卷名:容器内路径 # 具名 -v /宿主机路径:容器内路径 # 指定挂载路径 拓展 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx # ro 只读 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx # rw 可读可写 # 一旦这个设置了容器权限，容器对我们挂载出来的内容就有限定了 # ro 只要看到说明这个路径只能通过宿主机来操作，容器内部是无法操作的 3.4 Docker file 挂载# dockerfile 内容 # 基于centos镜像 FROM centos # 挂载两个匿名卷 VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 输出echo CMD echo &quot;---end---&quot; CMD /bin/bash #这里的每个命令都是镜像的一层 # 生成镜像 docker build -f dockerfile1 -t yukinocentos:1.0 . #执行镜像 ✘ yukino@Yukinos-Mac-mini  ~/Desktop/temp/dockerfile  docker run -it yukinocentos:1.0 /bin/sh sh-4.4# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var volume01 volume02 # 挂载的镜像 # 退出查看原数据 yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1c6ec60a439f yukinocentos:1.0 &quot;/bin/sh&quot; 2 minutes ago Up 2 minutes #查看原数据 docker inspect 1c6ec60a439f &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;e3002d4d1b7a1ea25504a7fdbdae8d1f103924c3b87930bb004a2e6c49259a67&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/e3002d4d1b7a1ea25504a7fdbdae8d1f103924c3b87930bb004a2e6c49259a67/_data&quot;, &quot;Destination&quot;: &quot;volume01&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; }, { &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;3ecffa507747fce5d61ab4779ceb9ce1a458167829d63101ab89d332f93cd49c&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/3ecffa507747fce5d61ab4779ceb9ce1a458167829d63101ab89d332f93cd49c/_data&quot;, &quot;Destination&quot;: &quot;volume02&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; } ], 不知道为啥，source 目录在mac上打不开 3.5 数据卷容器多个mysql容器之间数据同步 docker run -it --name docker01 yukinocentos:1.0 docker run -it --name docker02 --volumes-from docker01 yukinocentos:1.0 #相当于docker02继承了docker01 # 两个容器的数据卷volume01与volume02分别同步 bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var volume01 volume02 # 创建docker03 docker run -it --name docker03 --volumes-from docker01 yukinocentos:1.0 docker01 docker02 docker03 数据卷共享 当删除docker01后，docker02 docker03 数据依然存在 4. DockerFile4.1 命令 每个指令（关键字） 都是大写字母 FROM # 基础镜像，一切从这里开始构建 centos MAINTAINER # 镜像谁写的，姓名+邮箱 RUN # 镜像构建的时候需要运行的命令 ADD # 步骤：tomcat镜像，这个tomcat压缩包，添加内容 WORKDIR # 设置镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定对外的端口 RUN # 容器启动后要做的事 CMD # 指定容器启动的时候要运行的命令，只有最后一个会被生效 ENTRYPOINT # 指定这个容器的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令。触发指令 COPY # 类似ADD，将文件拷贝到镜像中 ENV # 构建时设置环境变量 4.2 构建自己的centosDocker Hub 中大部分镜像都是从这个基础镜像过来的FROM scratch，然后再构建 FROM centos MAINTAINER yukino&lt;233@qq.com&gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo &quot;---end---&quot; CMD /bin/bash # 构建镜像 yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker build -f yukinocentos -t mycentos:0.1 . [+] Building 168.9s (8/8) FINISHED =&gt; [internal] load build definition from yukinocentos 0.0s =&gt; =&gt; transferring dockerfile: 241B 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [internal] load metadata for docker.io/library/centos:latest 0.0s =&gt; CACHED [1/4] FROM docker.io/library/centos 0.0s =&gt; [2/4] WORKDIR /usr/local 0.0s =&gt; [3/4] RUN yum -y install vim 163.2s =&gt; [4/4] RUN yum -y install net-tools 5.1s =&gt; exporting to image 0.5s =&gt; =&gt; exporting layers 0.5s =&gt; =&gt; writing image sha256:018a20376d20419103f1e2941e3d932fd376380551617692bf6bf336b5932ca4 0.0s =&gt; =&gt; naming to docker.io/library/mycentos:0.1 # 启动image yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker run -it mycentos:0.1 [root@f2e629f64672 local]# pwd /usr/local # vim ifconfig 可以使用了 # 查看构建过程 docker history yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker history mycentos:0.1 IMAGE CREATED CREATED BY SIZE COMMENT 018a20376d20 4 minutes ago CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin/bash&quot;] 0B buildkit.dockerfile.v0 &lt;missing&gt; 4 minutes ago CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo \\&quot;---end---\\&quot;&quot;] 0B buildkit.dockerfile.v0 &lt;missing&gt; 4 minutes ago CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo $MYPATH&quot;] 0B buildkit.dockerfile.v0 &lt;missing&gt; 4 minutes ago EXPOSE map[80/tcp:{}] 0B buildkit.dockerfile.v0 &lt;missing&gt; 4 minutes ago RUN /bin/sh -c yum -y install net-tools # bu… 14.4MB buildkit.dockerfile.v0 &lt;missing&gt; 4 minutes ago RUN /bin/sh -c yum -y install vim # buildkit 58.1MB buildkit.dockerfile.v0 &lt;missing&gt; 7 minutes ago WORKDIR /usr/local 0B buildkit.dockerfile.v0 &lt;missing&gt; 7 minutes ago ENV MYPATH=/usr/local 0B buildkit.dockerfile.v0 &lt;missing&gt; 7 minutes ago MAINTAINER yukino&lt;233@qq.com&gt; 0B buildkit.dockerfile.v0 &lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7… 209MB 4.3 CMD 与 ENTRYPOINTENTRYPOINT # 指定这个容器的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令。触发指令 测试 CMD # DockerFile cmd-test yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  cat cmd-test FROM centos CMD [&quot;ls&quot;,&quot;-a&quot;] # 构建镜像 docker build -f cmd-test -t cmdtest . # 执行 ✘ yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker run -it cmdtest . .dockerenv dev home lib64 media opt root sbin sys usr .. bin etc lib lost+found mnt proc run srv tmp var # 追加命令,报错, -l 替换了 CMD [&quot;ls&quot;,&quot;-a&quot;]， -l不是命令，所以报错 yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker run -it cmdtest -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown. # 追加命令 ls -al 可行 ✘ yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker run -it cmdtest ls -al total 56 drwxr-xr-x 1 root root 4096 Jan 13 15:28 . drwxr-xr-x 1 root root 4096 Jan 13 15:28 .. -rwxr-xr-x 1 root root 0 Jan 13 15:28 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -&gt; usr/bin drwxr-xr-x 5 root root 360 Jan 13 15:28 dev drwxr-xr-x 1 root root 4096 Jan 13 15:28 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -&gt; usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -&gt; usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 148 root root 0 Jan 13 15:28 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -&gt; usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 13 root root 0 Jan 13 15:28 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var 测试 ENTRYPOINT # Docker file yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  cat dockerfile-entrypoint FROM centos ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] # 构建 docker build -f dockerfile-entrypoint -t entrypointtest . # 追加命令 -l 追加到了 ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]，不会报错 yukino@Yukinos-Mac-mini  ~/Desktop/temp/test  docker run -it entrypointtest -l total 56 drwxr-xr-x 1 root root 4096 Jan 13 15:32 . drwxr-xr-x 1 root root 4096 Jan 13 15:32 .. -rwxr-xr-x 1 root root 0 Jan 13 15:32 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -&gt; usr/bin drwxr-xr-x 5 root root 360 Jan 13 15:32 dev drwxr-xr-x 1 root root 4096 Jan 13 15:32 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -&gt; usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -&gt; usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 150 root root 0 Jan 13 15:32 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -&gt; usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 13 root root 0 Jan 13 15:28 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var 4.4 构建tomcat 5.发布镜像5.1 阿里云 进入阿里云容器镜像服务，创建镜像仓库 push 到 阿里云的步骤参考 阿里云里面的操作步骤即可 6.docker 网络# 运行容器 docker run -d -P --name tomcat01 tomcat # 执行 ip addr docker exec -it c864d7b91d46 ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/ipip 0.0.0.0 brd 0.0.0.0 3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000 link/tunnel6 :: brd :: 50: eth0@if51: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"/tags/docker/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Daily Review 2020-12","slug":"生活/Daily Review - 202012","date":"2020-12-31T03:30:00.000Z","updated":"2022-10-09T15:19:10.437Z","comments":true,"path":"2020/12/31/生活/Daily Review - 202012/","link":"","permalink":"/2020/12/31/生活/Daily Review - 202012/","excerpt":"","text":"leetcode 说明 *(看了一半) !(多解未看完) .跳过 1 2 3 4(*) 5 6 7 8 9 10(.) 11 12 13 14 15 16 17(.) 18 19(.) 20 21 … 26 27 28 175 176 177 178 180 181 182 183 184 185 186 197 262 595 596 601 620 626 627 1179 2020-12-29 下班时间 22:00 23:20 - 2:00 spring Boot 学习 如果能内部转岗就好了，留给我学习的时间不多了。 2020-12-28 下班时间 23:00 code review 00:00 - 1:50 BootStrap 使用 傻逼测试，卡我str4 2020-12-27 开始spring Boot项目学习，从14:00 - 1:00 github 三方登录 2020-12-26 下班时间 19:00 麻将 + 二麻酒馆 到凌晨2:00 2020-12-25 下班时间 22:00 2020-12-24 下班时间 22:00 code review 23:30 - 1:30 某些测试是傻叉，还有两天str4给我新bug标记str4，真tm恶心人 spring boot task学习 2020-12-23 下班时间 ~ code review 23:00 - 1:00 运动日，羽毛球打了个痛快 spring Boot swagger学习 2020-12-22 下班时间 21:15 code review 22:30 - 0:00 学习了 spring boot 整合 mybatis 2020-12-21 下班时间 22:00 code review 23:40 - 1:00 学习了spring boot jdbc用法 2020-12-20 code review 下午2点，陆陆续续到凌晨12:40 将spring Boot 的第一个项目学习了一遍 2020-12-19 加班 吃了兔肉火锅，真不错 打麻将，奋战到凌晨2点，又交学费了 学习 null 2020-12-18 null 2020-12-17 下班时间 20:40 code review 22:20 - 00:50 Spring Boot 学习，感觉找不到一个好的教程，这些视频感觉深井冰，基础都没学，就开始学源码，一脸懵逼。 2020-12-16 下班时间 21:00 code review 23:00 - 1:00 Spring boot继续跟进 2020-12-15 下班时间 21:20 code review 23:00 -1:00 SpringBoot源码配置ok,学习了SpringBoot源码的一点课程，很难 装修风格视频学习 2020-12-14 下班时间 20:20 code review 21:30 - 23:30 上班摸鱼 复习三道 leetcode mysql 开始学习spring boot 源码，环境准备中 装修风格视频学习 2020-12-13 本应自己炖汤，但是懒，没有坚持 code review Spring Boot 重新开始 宅了一天，学习了Spring Boot的一些基础知识，发现Spring Boot的源码太难了，听课一脸懵逼。与Spring 源码依赖很大，然而之前慕课网什么都没讲，真的服了。 2020-12-12 与朋友玩，羊肉汤不错，学会了打麻将，一直玩到凌晨2点，总之很久没这么开心了。 code review null 2020-12-9 - 11 B站学习尚硅谷的spring boot，版本太旧了，各种问题。准备换学习资料了。 2020-12-8 下班时间 20:30 code review 22:00 - 01:00 leetcode database [1179] 日语打卡 慕课网的spring boot居然是eclipse版本，劝退，找了B站尚硅谷的视频，发现别人的视频既免费，又讲得好。。。重新开始学习spring boot 考虑要不要将有道云笔记切换到Typora + 坚果云，有道云笔记手机端居然没有复制粘贴文章功能，太拉垮了。 2020-12-7 下班时间 21:30 code review 23:00 - 01:10 leetcode null 日语打卡 学习了spring boot的基础知识，感觉spring boot比spring mvc简单很多。 2020-12-6 code review 学习了 leetcode database [601 620 626 627] Spring mvc大概框架已经了解，下一步准备学习spring boot，这部分是重点。 日语 anki打卡 学习了山药炖排骨，nice 这周学习的时间还是太少了，接下来重点从mysql 转为 Java Web 业务代码 2020-12-5 下班时间 18:30 (周六加班) code review 学习了 leetcode database [197,262,595,596] 日语 anki打卡 2020-12-4 下班时间 18:30 null 2020-12-3 下班时间 20:50 code review 22:00 - 23:50 学习了 leetcode database [184,185,186] 日语 anki打卡 今日忙于解bug，无暇摸鱼 2020-12-2 下班时间 21:35 code reveiw 23:00 - 00:00 学习了 leetcode database [181,182,183] 日语 anki 打卡 运动日未运动 今日忙于解bug，无暇摸鱼 2020-12-1 下班时间21:00 code review 23:00 -00:30 学习了leetcode database [175,176,177,178,180] 日语anki 打卡 上班刷了两道 leetcode database 赚到了 今日忙于解bug 从今天开始记录每日支出","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"Daily Review","slug":"Daily-Review","permalink":"/tags/Daily-Review/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Daily Review 2020-11","slug":"生活/Daily Review - 202011","date":"2020-12-01T03:30:00.000Z","updated":"2022-10-09T15:19:10.437Z","comments":true,"path":"2020/12/01/生活/Daily Review - 202011/","link":"","permalink":"/2020/12/01/生活/Daily Review - 202011/","excerpt":"","text":"leetcode 说明 *(看了一半) !(多解未看完) .跳过 1 2 3 4(*) 5 6 7 8 9 10(.) 11 12 13 14 15 16 17(.) 18 19(.) 20 21 … 26 27 28 2020-11-30 下班时间 21:00 code review 22:40 - 00:40 leetcode null 复习了Spring mvc的相关内容，但还是有些逻辑没看懂，需要找时间再看一下。 anki 日语打卡 距离离职不到4个月了，任务很艰巨呀。得想办法上班多看书了。leetcode几乎停滞不前，上班挤时间刷题。 2020-11-29 周天搞 基线升级问题，打乱了我做饭的计划，shift 看了一会儿数据库的内容，不亏 2020-11-28 排查基线升级的问题 跟初中同学聚会，k歌 2020-11-27 null 2020-11-26 null 2020-11-25 下班时间 22:40 日语完成 leetcode null 2020-11-21 - 2020-11-24 leetcode null 复习了spring mvc实战项目 不可公开的情报 2020-11-20 下班时间 21:00 code review null leetcode null 日语 anki 打卡完成 哔哩哔哩越来越无聊了。有点想玩galgame了。 2020-11-19 下班时间 21:00 code review 22:30 - 23:30 leetcode [31] 日语 anki 打卡完成 没有运动，上班都是再浪费时间，好想跑路。 2020-11-18 下班时间 21:30 leetcode [29] 日语 anki累计清零 code review 23:00 - 24:00 2020-11-12 - 2020-11-13 不可公开的情报 2020-11-11 下班时间 20:30 leetcode [20 21 27 28] 日语单词，完成 上班刷了两道leetcode，赚到了 一小时羽毛球 抓住双十一的尾巴，花了 300 +，买了effective java 和 一些零食 2020-11-10 下班时间 20:30 leetcode [19] 日语单词，完成 2233故宫手办忍住没有剁手 2020-11-9 下班时间 21:30 leetcode [18] 日语单词，完成 2020-11-8 没有leetcode 睡到下午 收拾了房间 星期一开始要继续学习leetcode和日语了 2020-11-7 没有leetcode 只有加班 K歌到凌晨 2020-11-6 没有leetcode 只有加班 2020-11-6 没有leetcode 没有日语 只有加班 2020-11-5 下班时间 23:00 code study 00: - 00:30 项目出了两个出货必解的bug，加班到23:00，头好晕，感觉快吐了。实在无法学习了，早点休息吧。 leetcodep[16]涉及树，递归，下次好好看一下。 2020-11-4 下班时间 22:00 code study 23:00 - 00:50 leetcode [16] 学习了mysql基础。 日语学习记忆单词20个。 羽毛球一小时 2020-11-3 下班时间 21:00 code study 22:10 - 20:30 leetcode [15] 学习了mysql基础。 日语学习环境准备。 2020-11-2 下班时间 21:35 code study 23:00 - 00:35 leetcode [14] 学习了mysql基础。 日语学习环境准备。 2020-11-1 code study 从下午到晚上断断续续学习了6个小时 leetcode [7, 8, 9, 11, 12, 13] 学习了mysql基础。发现leetcode上有数据库练习 想学日语了。 喜欢上了宝藏up warma，喜欢warma的声音。于是我听了2个小时warma的boom电台 打算调整一下生活了，1点前睡觉，多吃水果。 2020-10-31 code study 23:30 - 0:00 下班时间：18:00 解决了几个bug，还剩下新项目的好多adsp crash。消解bug的速度不及报bug的速度。 三个月的头发终于剪了 1个小时骑车 leetcode [6] 2020-10-30 code study null 下班时间：23:30 搭建adsp环境搞了半天，幸好有小姐姐帮忙。 欠了一道leetcode没有刷 2020-10-29 code study 11:50 - 12:50 下班时间：11:00 刷了leetcode [5]题，学习了动态规划。 Daily Review 坚持日更新，保持学习状态 bug 真多 tony表示，内部转岗位，绩效B及以上且目标部门同意即可转。原部门不需要。 数据库学习是当务之急 2020-10-28 code study 12:00 - 1:47 下班时间：11:00 刷了leetcode [5]题，第5题不符合要求，需要重新学习，只学习了中心扩散解决最长回文。动态规划还需要学些 Daily Review 坚持日更新，保持学习状态 运动日羽毛球 1小时 bug 又开始催了。 2020-10-27 code study 11:00 - 1:00 下班时间：20:30 刷了leetcode [3,4]题，第4题不符合要求，需要重新学习 Daily Review 坚持日更新，保持学习状态 2020-10-26 code study 11:30 - 1:20 下班时间：21:10 今天宣布周六强制上班，讲个笑话，本分。 刷了leetcode [1,2]题，极其不熟练。想了半天。 Daily Review 坚持日更新，保持学习状态 2020-10-25 code study null 下班时间：null 从天府新区骑自行车到双流区，3个半小时。吃了红湖莲藕汤锅汤锅，感觉还不错 2020-10-24 code study 0:00 - 5:00 下班时间：6:00 上了一天班，最后发现困扰了我两天的问题居然是编译问题，浪费我的时间 进城吃了串串和太古里逛街，iphone12的屏幕和机身手感，让人失望 通宵准备字节跳动面试，面试结果，惨败，算法和网络协议是我的短板。接下来刷leetcode 2020-10-23 code study null 下班时间：21:30 null 遇到神奇的事情了。莫名其妙的bug解了两天。怕是编译环境的问题吧 Daily Review 坚持日更新，保持学习状态 太累了。无法学习。明天是学习还是继续上班？ 2020-10-22 code study 00:30 - 1:30 下班时间：23:40 Web基础与数据处理 项目初期，各种问题，硬件又开始催了。反正遇到问题就是阻塞，就是很严重。现在是人越来越少，项目周期越来越短，项目越来越多。我真的服了，劝退警告。 Daily Review 坚持日更新，保持学习状态 太累了，学习状态不好，感觉要学习的内容太多了。之前学习的java后端的基础忘得差不多了。这次面试怕是凉透了。 2020-10-21 code study 22:45 - 1:30 下班时间：20:40 Java的基础知识，多线程，JVM，GC简介 完成课程分享，如释重负 Daily Review 坚持日更新，保持学习状态 运动日，bug太多，没有时间打球。 2020-10-20 code study 23:50 - 1:50 下班时间 : 22:20 Java的基础知识，准备面试内容 Daily Review 坚持日更新，保持学习状态 解bug的速度远比不上报bug的速度。又报了一大波产线问题 修改了简历。 明天有音频基础知识授课。明天早上准备一波 2020-10-19 code study 22:30 - 1:45 下班时间 : 21:20 spring mvc 的 restful风格 和 拦截器 Daily Review 坚持日更新，保持学习状态 字节跳动 面试邀请，接下来的一周准备面试 中移物联网，还未修改简历，准备投一波 oppo的工作好忙，项目的一大波bug要解，一大波feature需要移植","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"Daily Review","slug":"Daily-Review","permalink":"/tags/Daily-Review/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"拦截器-Interceptor","slug":"技术/拦截器-Interceptor","date":"2020-10-19T17:50:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/20/技术/拦截器-Interceptor/","link":"","permalink":"/2020/10/20/技术/拦截器-Interceptor/","excerpt":"","text":"拦截器(Interceptor)用于对URL请求进行前置/后置过滤 Interceptor与Filter用途相似，但实现方式不同 Interceptor底层就是基于Spring Aop面向切面编程实现 1.拦截器入门&lt;!--pom.xml--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--applicationContext.xml--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; @RestController @RequestMapping(&quot;/restful&quot;) //@CrossOrigin(origins = {&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;}) //@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600) public class RestfulController { @GetMapping(&quot;/persons&quot;) public List&lt;Person&gt; findPersons(){ List list = new ArrayList(); Person p1 = new Person(); p1.setName(&quot;lily&quot;); p1.setAge(23); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;smith&quot;); p2.setAge(22); p2.setBirthday(new Date()); list.add(p1); list.add(p2); System.out.println(&quot;RestfulController.findPersons() - return list&quot;); return list; } } public class MyInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL() + &quot;-准备执行&quot;); // response.getWriter().print(&quot;[]&quot;); return true;//返回false会直接拦截，不进行下一步传递 } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;); } } preHandle -前置执行处理 postHandle - 目标资源已经被Spring mvc 框架处理 afterCompletion - 响应文本已经产生 打印log http://localhost:8080/restful/persons-准备执行 RestfulController.findPersons() - return list http://localhost:8080/restful/persons-目标处理成功 http://localhost:8080/restful/persons-响应内容已产生 静态资源处理 因为按照上面的配置，当访问静态资源也会进行拦截，显然这是不合理的。 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt; &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 手动排除静态资源/**.ico 将静态资源放在统一目录/resource/ 指定访问的链接 /restful/** 2.多拦截器问题 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt; &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt; &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; public class MyInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL() + &quot;-准备执行&quot;); // response.getWriter().print(&quot;[]&quot;);//拦截器输出到前端 return true;//返回false会直接拦截，不进行下一步传递 } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;); } } public class MyInterceptor1 implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL()+&quot;-准备执行-1&quot;); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL()+&quot;-目标处理成功-1&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL()+&quot;-响应内容已产生-1&quot;); } } 执行log http://localhost:8080/restful/persons-准备执行http://localhost:8080/restful/persons-准备执行-1RestfulController.findPersons() - return listhttp://localhost:8080/restful/persons-目标处理成功-1http://localhost:8080/restful/persons-目标处理成功http://localhost:8080/restful/persons-响应内容已产生-1http://localhost:8080/restful/persons-响应内容已产生 3.用户流量拦截器 引入logback &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 新建 resource/logback.xml&lt;!--logback.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;!--定义向控制台输出的追加器--&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d %level %logger{10} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--定义向log文件输出的追加器--&gt; &lt;appender name=&quot;accessHistoryLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;d:/logs/history.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d %level %logger{10} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出最低级别debug--&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;/root&gt; &lt;logger name=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt; &lt;!--level=&quot;INFO&quot; 默认输出等级 additivity=&quot;false&quot; 表示不输出到console，输出到文件--&gt; &lt;appender-ref ref=&quot;accessHistoryLog&quot;/&gt; &lt;/logger&gt; &lt;/configuration&gt; &lt;!--applicationContext.xml--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;pattern&gt;[%thread] %d %level %logger{10} - %msg%n&lt;/pattern&gt; %pattern 线程名 %d 时间 %level 日志级别 %logger{10} 产生类日志，限定长度10 %msg log信息 %n 换行 RollingFileAppender 生成按天滚动的文件。每一天一个文件。 public class AccessHistoryInterceptor implements HandlerInterceptor { private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class); public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { StringBuilder log = new StringBuilder(); log.append(request.getRemoteAddr()); log.append(&quot;|&quot;); log.append(request.getRequestURL()); log.append(&quot;|&quot;); log.append(request.getHeader(&quot;user-agent&quot;)); logger.info(log.toString()); return true; } } 4.Spring MVC处理流程","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"/tags/Spring-MVC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Restful风格","slug":"技术/Restful","date":"2020-10-19T13:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/19/技术/Restful/","link":"","permalink":"/2020/10/19/技术/Restful/","excerpt":"","text":"0. 基础介绍Restful开发规范 使用URL作为用户交互入口 明确的语义规范(GET|POST|PUT|DELETE) GET 查询 POST 新增 PUT 修改 DELETE 删除 Refstful命名要求 1.环境准备&lt;!--web.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; &lt;!--applicationContext.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt; &lt;/beans&gt; 2.Restful 注解 @RestController - 使用在类上，替代每个@ResponseBody，代表是restful数据而不是页面跳转 @PathVariable - 路径变量注解 @GetMapping @PostMapping -对应请求注解 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;RESTful实验室&lt;/title&gt; &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&quot;#btnGet&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;get&quot; , dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) $(function(){ $(&quot;#btnPost&quot;).click(function () { $.ajax({ url : &quot;/restful/request/100&quot;,//路径变量100 type : &quot;post&quot; , data : &quot;name=lily&amp;age=23&quot;,//数据 dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id); } }) }); }) $(function(){ $(&quot;#btnPut&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;put&quot; , data : &quot;name=lily&amp;age=23&quot;, dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) $(function(){ $(&quot;#btnDelete&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;delete&quot; , dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) $(function () { $(&quot;#btnPersons&quot;).click(function () { $.ajax({ url : &quot;/restful/persons&quot;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function(json){ console.info(json); for(var i = 0 ; i &lt; json.length;i++){ var p = json[i]; $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;) } } }) }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt; &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt; &lt;hr/&gt; &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt; &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; @RestController //替代每个@ResponseBody，代表是restful数据而不是页面跳转 @RequestMapping(&quot;/restful&quot;) public class RestfulController { @GetMapping(&quot;/request&quot;) //@ResponseBody public String doGetRequest(){ return &quot;{\\&quot;message\\&quot;:\\&quot;返回查询结果\\&quot;}&quot;; } // POST /article/1 // POST /restful/request/100 // 获取路径变量 @PostMapping(&quot;/request/{rid}&quot;) //@ResponseBody public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据新建成功\\&quot;,\\&quot;id\\&quot;:&quot; + requestId + &quot;}&quot;; } @PutMapping(&quot;/request&quot;) //@ResponseBody public String doPutRequest(Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据更新成功\\&quot;}&quot;; } @DeleteMapping(&quot;/request&quot;) //@ResponseBody public String doDeleteRequest(){ return &quot;{\\&quot;message\\&quot;:\\&quot;数据删除成功\\&quot;}&quot;; } } 3.简单请求与非简单请求 简单请求是指标准结构的HTTP请求,对应GET/POST请求 非简单请求是复杂要求的HTTP请求,指PUT/DELETE、扩展标准请求 两者最大区别是非简单请求发送前需要发送预检请求 非简单请求 &lt;script&gt; $(function(){ $(&quot;#btnPost&quot;).click(function () { $.ajax({ url : &quot;/restful/request/100&quot;, type : &quot;post&quot; , data : &quot;name=lily&amp;age=23&quot;, dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id); } }) }); }) $(function(){ $(&quot;#btnPut&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;put&quot; , data : &quot;name=lily&amp;age=23&quot;, dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) &lt;/script&gt; @PostMapping(&quot;/request/{rid}&quot;) //@ResponseBody public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据新建成功\\&quot;,\\&quot;id\\&quot;:&quot; + requestId + &quot;}&quot;; } @PutMapping(&quot;/request&quot;) //@ResponseBody public String doPutRequest(Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据更新成功\\&quot;}&quot;; } 由于Post请求是简单请求,可以得到执行结果 lily:23 但Put请求是非简单请求，执行结果 null:null 为了使非简单请求，能够获取到数据。需要在web.xml增加配置 &lt;!--web.xml--&gt; &lt;filter&gt; &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.FormContentFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 4.JSON序列化public class Person { private String name; private Integer age; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot; , timezone = &quot;GMT+8&quot;) private Date birthday; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } } @JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss” , timezone = “GMT+8”) 对日期进行格式化，JackSon的默认时区为格林尼治时间(GMT),北京时间为东八区。需要进行转换时区。 @GetMapping(&quot;/person&quot;) public Person findByPersonId(Integer id){ Person p = new Person(); if(id==1){ p.setName(&quot;lily&quot;); p.setAge(23); }else if(id==2){ p.setName(&quot;smith&quot;); p.setAge(22); } return p; } @GetMapping(&quot;/persons&quot;) public List&lt;Person&gt; findPersons(){ List list = new ArrayList(); Person p1 = new Person(); p1.setName(&quot;lily&quot;); p1.setAge(23); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;smith&quot;); p2.setAge(22); p2.setBirthday(new Date()); list.add(p1); list.add(p2); return list; } &lt;script&gt; $(function () { $(&quot;#btnPersons&quot;).click(function () { $.ajax({ url : &quot;/restful/persons&quot;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function(json){ console.info(json); for(var i = 0 ; i &lt; json.length;i++){ var p = json[i]; $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;) } } }) }) }) &lt;/script&gt; &lt;body&gt; &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt; &lt;hr/&gt; &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt; &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt; &lt;/body&gt; 5.跨域请求5.1 跨域基础知识浏览器同源策略 同源策略阻止一个域加载的脚本去获取另一个域上的资源 只要协议、域名、端口有一个不同，都被当作是不同的域 浏览器Console看到 Access-Control-Allow-Origin就代表跨域了 同源策略示例 HTML中允许跨域的标签 &lt;img&gt; - 显示远程图片 &lt;script&gt; - 加载远程JS &lt;link&gt; - 加载远程CSS 个人经历 年少时玩爬虫的时候，目标是直接爬取B站的数据，直接显示在自己的界面。B站有一个服务器，是restful风格提供数据。通过前端直接去B站服务器的Json数据。结果发现一直是无法成功获取。这个问题就是同源策略。后面还是只有通过后端语音拿到数据再传到前端瞬间实现。 CORS跨域资源访问 CORS是一种机制,使用额外的HTTP头通知浏览器可以访问其他域，其实是浏览器发现是跨域，所以进行拦截了。 URL响应头包含 Access-Control-*指明请求允许跨域，浏览器发现带有这个response头，就放行了。 跨域访问，在Request Headers中，有字段Sec-Fetch-Mode: cors5.2 Spring MVC解决跨域访问 @CrossOrigin－ Controller跨域注解 mvc:cors - Spring MVC全局跨域配置 @CrossOrigin`Java@RestController//替代每个@ResponseBody，代表是restful数据而不是数据跳转@RequestMapping(“/restful”)//@CrossOrigin(origins = {“http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;})//@CrossOrigin(origins = “*”,maxAge = 3600)public class RestfulController { } 在Controller类上添加注解 `@CrossOrigin(origins = {&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;})` `@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)` maxAge的意思是浏览器的非简单请求在实际请求之前，会先发送预检请求。 maxAge 即保存预简请求的时间，在这期间。非简单请求就不用发送预检请求了，缓解服务器的压力。 2. &lt;mvc:cors&gt; ```Xml &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/restful/**&quot; allowed-origins=&quot;http://localhost:8080,http://www.imooc.com&quot; max-age=&quot;3600&quot;/&gt; &lt;/mvc:cors&gt; 其中 path=&quot;/restful/** 表示访问的目标域名为restful/ 下的所有域名 总结 mvc:cors 的优势方便配置全局跨域访问。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"/tags/Spring-MVC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Spring MVC","slug":"技术/Spring MVC","date":"2020-10-18T13:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/18/技术/Spring MVC/","link":"","permalink":"/2020/10/18/技术/Spring MVC/","excerpt":"","text":"1.环境配置&lt;!--web.xml--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- DispatcherServlet是Spring MVC最核心的对象 DispatcherServlet用于拦截Http请求, 并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--applicationContext.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 在Web应用启动时自动创建Spring IOC容器, 并初始化DispatcherServlet --&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--&quot;/&quot; 代表拦截所有请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中,自动创建并管理com.imooc.springmvc及子包中 拥有以下注解的对象. @Repository @Service @Controller @Component --&gt; &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt; &lt;!--1.启用Spring MVC的注解开发模式--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 将图片/JS/CSS等静态资源排除在外,可提高执行效率 --&gt; &lt;mvc:default-servlet-handler/&gt; 2.URL Mapping注解作用URL Mapping将URL与Controller方法进行绑定 RequestMapping - 通用绑定 GetMaping - 绑定Get请求 PostMapping - 绑定Post请求 前端Post 请求 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;&gt; &lt;br&gt; &lt;input name=&quot;password&quot;&gt; &lt;br&gt; &lt;input name=&quot;createTime&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; @Controller @RequestMapping(&quot;/um&quot;) //为所有类的映射都添加一个前缀 public class URLMappingController { @GetMapping(&quot;/g&quot;) @ResponseBody //manager_name参数映射到String managerName //Date createTime 是使用MyDateConverter类在applicationContext.xml配置进行日期转换的 public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName,Date createTime){ System.out.println(&quot;managerName:&quot; + managerName); System.out.println(createTime); return &quot;This is get method&quot;; } @PostMapping(&quot;/p&quot;) @ResponseBody public String postMapping(String username, Long password) { System.out.println(username + &quot;:&quot; + password); return &quot;This is post method&quot;; } @PostMapping(&quot;/p1&quot;) @ResponseBody //1.可以用对象User进行接收Post参数，其中createTime字段，在User类中，需要使用DateTimeFormat //2.单独接收createTime 时，也可以形式参数中@DateTimeFormat，指明格式 //3.String username也可以接收到数据 public String postMapping(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime) { System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword()); System.out.println(&quot;date:&quot; + user.getCreateTime()); return &quot;&lt;h1&gt;这是Post响应&lt;/h1&gt;&quot;; } } public class User { private String username; private Long password; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date createTime; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getPassword() { return password; } public void setPassword(Long password) { this.password = password; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } 3.接收表单复杂数据&lt;div class=&quot;container&quot;&gt; &lt;h2&gt;学员调查问卷&lt;/h2&gt; &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt; &lt;h3&gt;您的姓名&lt;/h3&gt; &lt;input name=&quot;name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt; &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt; &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt; &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt; &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt; &lt;/select&gt; &lt;div&gt; &lt;h3&gt;您的学习目的：&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他 &lt;/div&gt; &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; @Controller public class FormContoller { @PostMapping(&quot;/apply&quot;) @ResponseBody //1.@RequestParam 指定接收到的参数为n,默认值为&quot;ANON&quot;,可避免无法匹配到参数时，出现的异常 //2.复选框使用数组Integer[] purpose，接收 public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose) { System.out.println(&quot;name:&quot; + name); System.out.println(&quot;course:&quot; + course); for(Integer p : purpose){ System.out.println(&quot;purpose:&quot; + p); } return &quot;SUCCES&quot;; } // @PostMapping(&quot;/apply&quot;) @ResponseBody //@RequestParam表示将接收到的数据转换成List，一定要加 public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose){ System.out.println(&quot;name:&quot; + name); System.out.println(&quot;course:&quot; + course); for(Integer p : purpose){ System.out.println(&quot;purpose:&quot; + p); } return &quot;SUCCES&quot;; } // @PostMapping(&quot;/apply&quot;) @ResponseBody //以对象方式接收参数 public String apply(Form form) { System.out.println(form.getName()); System.out.println(form.getCourse()); for(Integer p : form.getPurpose()) { System.out.println(p); } return &quot;SUCCESS&quot;; } // @PostMapping(&quot;/apply&quot;) @ResponseBody //注意Map类型最好不要用因为Map类型对于传过来的purpose参数，对于复杂类型，如复选框，只会取第一个值。漏掉数据 public String apply(@RequestParam Map map){ System.out.println(map); return &quot;SUCCESS&quot;; } } public class Form { private String name; private String course; private List&lt;Integer&gt; purpose; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCourse() { return course; } public void setCourse(String course) { this.course = course; } public List&lt;Integer&gt; getPurpose() { return purpose; } public void setPurpose(List&lt;Integer&gt; purpose) { this.purpose = purpose; } } 4.关联对象赋值 &lt;h2&gt;学员调查问卷&lt;/h2&gt; &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt; &lt;h3&gt;您的姓名&lt;/h3&gt; &lt;input name=&quot;name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt; &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt; &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt; &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt; &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt; &lt;/select&gt; &lt;div&gt; &lt;h3&gt;您的学习目的：&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他 &lt;/div&gt; &lt;h3&gt;收货人&lt;/h3&gt; &lt;input name=&quot;delivery.name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;联系电话&lt;/h3&gt; &lt;input name=&quot;delivery.mobile&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;收货地址&lt;/h3&gt; &lt;input name=&quot;delivery.address&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt; &lt;/div&gt; &lt;/form&gt; delivery.name delivery.mobile delivery.address public class Delivery { private String name; private String address; private String mobile; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getMobile() { return mobile; } public void setMobile(String mobile) { this.mobile = mobile; } } public class Form { private String name; private String course; private List&lt;Integer&gt; purpose; private Delivery delivery = new Delivery();//关联对象 public Delivery getDelivery() { return delivery; } public void setDelivery(Delivery delivery) { this.delivery = delivery; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCourse() { return course; } public void setCourse(String course) { this.course = course; } public List&lt;Integer&gt; getPurpose() { return purpose; } public void setPurpose(List&lt;Integer&gt; purpose) { this.purpose = purpose; } } @PostMapping(&quot;/apply&quot;) @ResponseBody //注意Map类型最好不要用因为Map类型对于传过来的purpose参数，只会取第一个 public String applyDelivery(Form form){ System.out.println(form.getDelivery().getName()); return &quot;SUCCESS&quot;; } 5.日期转换 @DateTimeFormat指定格式，将String 类型转换称日期类型 @PostMapping(&quot;/p1&quot;) @ResponseBody //1.可以用对象User进行接收Post参数，其中createTime字段，在User类中，需要使用DateTimeFormat //2.单独接收createTime 时，也可以形式参数中@DateTimeFormat，指明格式 public String postMapping(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime) { System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword()); System.out.println(&quot;date:&quot; + user.getCreateTime()); return &quot;&lt;h1&gt;这是Post响应&lt;/h1&gt;&quot;; } 对象成员 注解 public class User { private String username; private Long password; //@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date createTime; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getPassword() { return password; } public void setPassword(Long password) { this.password = password; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } public String postMapping(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime) { System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword()); System.out.println(&quot;date:&quot; + user.getCreateTime()); return &quot;&lt;h1&gt;这是Post响应&lt;/h1&gt;&quot;; } User 对象的成员变量自动转换 自定义日期转换类 //日期转换 public class MyDateConverter implements Converter&lt;String, Date&gt; { public Date convert(String s) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try { Date d = sdf.parse(s); return d; } catch (ParseException e) { return null; } } } &lt;!--applicationContext.xml--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;!--指定日期转换类--&gt; &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; @GetMapping(&quot;/g&quot;) @ResponseBody //manager_name参数映射到String managerName //Date createTime 是使用MyDateConverter类在applicationContext.xml配置进行日期转换的 public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName,Date createTime){ System.out.println(&quot;managerName:&quot; + managerName); System.out.println(createTime); return &quot;This is get method&quot;; } Date createTime 没有加注解，也可以转换 注意：注解与自定义日期转换类同时存在时，以日期转换类优先 6.中文乱码问题 Get乱码问题 - server.xml增加URIEncoding属性 Post请求乱码 - Web.xml 配置 CharacterEncodingFilter Response响应乱码 - spring配置StringHttpMessageConverter 6.1 getPath:”Tomcat v8.5 Server at localhost-config\\server.xml” &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 在tomcat8 以下的版本需要增加URIEncoding，以上版本默认是UTF-8 6.2 post通过过滤器来实现post编码 &lt;!--web.xml--&gt; &lt;filter&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 6.3 Response&lt;!--applicationContext.xml--&gt; &lt;!--3.message-converters 配置Response响应字符集--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt; &lt;value&gt;text/plain;charset=utf-8&lt;/value&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 7.响应输出7.1 ModelAndView","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"/tags/Spring-MVC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Spring 事务管理","slug":"技术/Spring 事务管理","date":"2020-10-18T07:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/18/技术/Spring 事务管理/","link":"","permalink":"/2020/10/18/技术/Spring 事务管理/","excerpt":"","text":"什么是事务？ 事务一般指的是数据库事务(Database Transaction),是指一个程序执行单元，要么完全执行，要么完全不执行 事务并发问题 脏读 解决方法：只能读取永久数据，不能读取内存中的数据 不可重复读 解决方法：锁行 幻读 解决方法：锁表 Mysql事务隔离级别 JDBC事务隔离级别 事务传播行为 0. 公共代码&lt;!--spring-dao.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/os?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;foreverlove&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--在 XML 配置文件中启动 Spring 的自动扫描功能 我们就不再需要在 XML 中显式使用 &lt;bean/&gt; 进行Bean 的配置。 Spring 在容器初始化时将自动扫描 com.imooc.os.dao 指定的包及其子包下的所有 class文件， 所有标注了 @Repository 的类都将被注册为 Spring Bean。 --&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.dao&quot;/&gt; &lt;/beans&gt; @Repository public class OrderDaoImpl implements OrderDao { @Autowired private JdbcTemplate jdbcTemplate; public void insert(Order order) { String sql = &quot;insert into orders values(?,?,?,?,?,?,?,?,?,?,?)&quot;; jdbcTemplate.update(sql,order.getId(),order.getProductsId(),order.getNumber(),order.getPrice(),order.getCreateTime(),order.getSendTime(),order.getConfirmTime(),order.getConsignee(),order.getConsigneePhone(),order.getConsigneeAddress(),order.getStatus()); } public void update(Order order) { String sql = &quot;update orders set create_time=?,send_time=?,confirm_time=?,consignee=?,consignee_phone=?,consignee_address=?,status=? where id=?&quot;; jdbcTemplate.update(sql,order.getProductsId(),order.getNumber(),order.getPrice(),order.getCreateTime(),order.getSendTime(),order.getConfirmTime(),order.getConsignee(),order.getConsigneePhone(),order.getConsigneeAddress(),order.getStatus(),order.getId()); } public void delete(String id) { String sql = &quot;delete from orders where id=?&quot;; jdbcTemplate.update(sql,id); } public Order select(String id) { String sql = &quot;select form orders where id=?&quot;; return jdbcTemplate.queryForObject(sql,new OrderRowMapper(),id); } public List&lt;Order&gt; select() { String sql = &quot;select form orders&quot;; return jdbcTemplate.query(sql,new OrderRowMapper()); } private class OrderRowMapper implements RowMapper&lt;Order&gt;{ public Order mapRow(ResultSet resultSet, int i) throws SQLException { Order order=new Order(); order.setId(resultSet.getString(&quot;id&quot;)); order.setProductsId(resultSet.getString(&quot;product_id&quot;)); order.setNumber(resultSet.getInt(&quot;number&quot;)); order.setPrice(resultSet.getDouble(&quot;price&quot;)); order.setCreateTime(resultSet.getTimestamp(&quot;create_time&quot;)); order.setSendTime(resultSet.getTimestamp(&quot;send_time&quot;)); order.setConfirmTime(resultSet.getTimestamp(&quot;confirm_time&quot;)); order.setConsignee(resultSet.getString(&quot;consignee&quot;)); order.setConsigneePhone(resultSet.getString(&quot;consignee_phone&quot;)); order.setConsigneeAddress(resultSet.getString(&quot;consignee_address&quot;)); order.setStatus(resultSet.getString(&quot;status&quot;)); return order; } } } @Repository public class ProductDaoImpl implements ProductDao { @Autowired private JdbcTemplate jdbcTemplate; public void insert(Product product) { String sql = &quot;insert into products values(?,?,?,?,?)&quot;; jdbcTemplate.update(sql,product.getId(),product.getTitle(),product.getPrice(),product.getStock(),product.getStatus()); } public void update(Product product) { String sql = &quot;update products set title=?,price=?,stock=?,status=? where id=?&quot;; jdbcTemplate.update(sql,product.getTitle(),product.getPrice(),product.getStock(),product.getStatus(),product.getId()); } public void delete(String id) { String sql = &quot;delete form products where id=?&quot;; jdbcTemplate.update(sql,id); } public Product select(String id) { String sql = &quot;select * from products where id=?&quot;; return jdbcTemplate.queryForObject(sql,new ProductRowMapper(),id); } public List&lt;Product&gt; select() { String sql = &quot;select * from products&quot;; return jdbcTemplate.query(sql,new ProductRowMapper()); } private class ProductRowMapper implements RowMapper&lt;Product&gt;{ public Product mapRow(ResultSet resultSet, int i) throws SQLException { Product product = new Product(); product.setId(resultSet.getString(&quot;id&quot;)); product.setTitle(resultSet.getString(&quot;title&quot;)); product.setPrice(resultSet.getDouble(&quot;price&quot;)); product.setStock(resultSet.getInt(&quot;stock&quot;)); product.setStatus(resultSet.getString(&quot;status&quot;)); return product; } } } 1.Spring编程式事物处理1.1 方式1 基于底层API的编程式事物处理 PlatformTransactionManager TransactionDefinition TransactionStatus &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl1&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionDefinition&quot; class=&quot;org.springframework.transaction.support.DefaultTransactionDefinition&quot;&gt; &lt;property name=&quot;propagationBehaviorName&quot; value=&quot;PROPAGATION_REQUIRED&quot;/&gt; &lt;!--PROPAGATION_REQUIRED 表示 事务传播行为--支持当前事务，如果没有当前事务，就新建一个事务--&gt; &lt;!--也可配置隔离级别等其他属性，不配置即使用默认--&gt; &lt;/bean&gt; &lt;/beans&gt; package com.imooc.os.service; import com.imooc.os.entity.Order; public interface OrderService { void addOrder(Order order); } /*1.基于底层API的方式 PlatformTransactionManager TransactionDefinition*/ @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; @Autowired private PlatformTransactionManager transactionManager; @Autowired private TransactionDefinition transactionDefinition; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); //开启事务 TransactionProxyFactoryBean transactionProxyFactoryBean; TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition); try { orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); //结束事务 transactionManager.commit(transactionStatus); }catch (Exception e){ e.printStackTrace(); //出问题，将未提交的sql回滚 transactionManager.rollback(transactionStatus); } } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service1.xml&quot;) //1.基于底层api的编程式事务处理方式 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 1.2 基于TransactionTemplate的编程式事务管理 TransactionTemplate &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl2&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; //2.基于TransactionTemplate的编程式事务管理 @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; //2.TransactionTemplate 用于简化底层API @Autowired private TransactionTemplate transactionTemplate; public void addOrder(final Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); transactionTemplate.execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus transactionStatus) { try { orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); //不需要提交，TransactionTemplate会帮你提交 }catch (Exception e){ e.printStackTrace(); transactionStatus.setRollbackOnly();//回滚 } return null; } }); } } public interface OrderService { void addOrder(Order order); } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service2.xml&quot;) //2.基于TransactionTemplate的编程式事务管理 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.Spring声明式事务处理简介 Spring的声明式事务处理是建立在AOP的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或加一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 建议在开发中使用声明式事务，使得业务代码纯粹干净，方便后期代码维护 分类 基于TransactionInterceptor的声明式事务处理。 基于TransactionProxyFactoryBean的声明式事务处理。 基于 命名空间的声明式事物管理。 基于 @Transactional的声明式事务管理。 2.1 基于TransactionInterceptor的声明式事务处理。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--1.基于TransactionInterceptor的声明式事务处理--&gt; &lt;bean id=&quot;orderServiceTarget&quot; class=&quot;com.imooc.os.service.impl.OrderServiceImpl&quot;/&gt; &lt;bean id=&quot;transactionInterceptor&quot; class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt; &lt;!--配置事务管理器--&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;!--配置拦截器--&gt; &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;!--key是方法，配置事务传播行为，属性--&gt; &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;find*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;search*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--用拦截器增强目标类，建立关联--&gt; &lt;bean id=&quot;orderService&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;orderServiceTarget&quot;/&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;idref bean=&quot;transactionInterceptor&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } 对于addOrder，由于拦截器增强，出错时，这个函数的操作自动回滚。 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service3.xml&quot;) //3.基于TransactionInterceptor的声明式事务处理 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.2 基于TransactionProxyFactoryBean的声明式事务处理&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--2.基于TransactionProxyFactoryBean的声明式事务处理，其实就是简化上面的那种拦截器--&gt; &lt;bean id=&quot;orderServiceTarget&quot; class=&quot;com.imooc.os.service.impl.OrderServiceImpl&quot;/&gt; &lt;bean id=&quot;orderService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;find*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;search*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;target&quot; ref=&quot;orderServiceTarget&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service4.xml&quot;) //4.基于TransactionProxyFactoryBean的声明式事务处理，其实就是简化上面的那种拦截器 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.3 (最推荐)基于 命名空间的声明式事物管理。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--3.基于&lt;tx&gt;命名空间的声明式事务处理，这种是实际开发常用的--&gt; &lt;!--增加通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--增强的地方,在哪个方法增强--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc.os.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service5.xml&quot;) //5.基于&lt;tx&gt;命名空间的声明式事务处理，这种是实际开发常用的 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.4 基于 @Transactional的声明式事务管理。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl6&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--4.基于@Transactional的声明式事务管理--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; //4.基于@Transactional的声明式事务管理 @Transactional(propagation = Propagation.REQUIRED) public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service6.xml&quot;) //6.基于@Transactional的声明式事务管理,这种是实际开发常用的 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"JDBC Template","slug":"技术/JDBC Template","date":"2020-10-17T06:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/17/技术/JDBC Template/","link":"","permalink":"/2020/10/17/技术/JDBC Template/","excerpt":"","text":"1.JDBC Template简介Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。 2.codespring.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;foreverlove&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--在 XML 配置文件中启动 Spring 的自动扫描功能 我们就不再需要在 XML 中显式使用 &lt;bean/&gt; 进行Bean 的配置。 Spring 在容器初始化时将自动扫描 com.imooc.sc 指定的包及其子包下的所有 class文件， 所有标注了 @Repository 的类都将被注册为 Spring Bean。 --&gt; &lt;context:component-scan base-package=&quot;com.imooc.sc&quot;/&gt; &lt;/beans&gt; 基本操作手法 public class Test { private JdbcTemplate jdbcTemplate; { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); jdbcTemplate = (JdbcTemplate)context.getBean(&quot;jdbcTemplate&quot;); } //create @org.junit.Test public void testExecute(){ jdbcTemplate.execute(&quot;create table user1(id int,name varchar(20))&quot;); } //insert @org.junit.Test public void testUpdate(){ String sql = &quot;insert into student(name,sex) values(?,?)&quot;; jdbcTemplate.update(sql,new Object[]{&quot;张飞&quot;,&quot;男&quot;}); } //update @org.junit.Test public void testUpdate2(){ String sql = &quot;update student set sex=? where id=?&quot;; jdbcTemplate.update(sql,&quot;女&quot;,1); } //批量更新 @org.junit.Test public void testBatchUpdate(){ String[] sqls={ &quot;insert into student(name,sex) values(&#39;关羽&#39;,&#39;女&#39;)&quot;, &quot;insert into student(name,sex) values(&#39;刘备&#39;,&#39;男&#39;)&quot;, &quot;update student set sex=&#39;女&#39; where id=1&quot; }; jdbcTemplate.batchUpdate(sqls); } //批量更新 public void testBatchUpdate2(){ String sql = &quot;insert into selection(student,course) values(?,?)&quot;; List&lt;Object[]&gt; list = new ArrayList&lt;Object[]&gt;(); list.add(new Object[]{1005,1001}); list.add(new Object[]{1005,1003}); jdbcTemplate.batchUpdate(sql,list); } //查询 @org.junit.Test public void testQuerySimple1(){ String sql = &quot;select count(*) from student&quot;; int count = jdbcTemplate.queryForObject(sql,Integer.class); System.out.println(count); } @org.junit.Test public void testQuerySimple2(){ String sql = &quot;select name from student where sex=?&quot;; List&lt;String&gt; names = jdbcTemplate.queryForList(sql,String.class,&quot;女&quot;); System.out.println(names); } //查询结果为map @org.junit.Test public void testQueryMap1(){ String sql = &quot;select * from student where id = ?&quot;; Map&lt;String,Object&gt; stu = jdbcTemplate.queryForMap(sql,1); System.out.println(stu);//{id=1, name=张飞, sex=女, born=null} } @org.junit.Test public void testQueryMap2(){ String sql = &quot;select * from student&quot;; List&lt;Map&lt;String,Object&gt;&gt; stus = jdbcTemplate.queryForList(sql); System.out.println(stus); //[{id=1, name=张飞, sex=女, born=null}, {id=2, name=关羽, sex=女, born=null}] } //查询结果返回对象 public void testQueryEntity1(){ String sql = &quot;select * from student where id = ?&quot;; Student stu = jdbcTemplate.queryForObject(sql, new StudentRowMapper(), 1004); System.out.println(stu); } @org.junit.Test public void testQueryEntity2(){ String sql = &quot;select * from student&quot;; List&lt;Student&gt; stus = jdbcTemplate.query(sql,new StudentRowMapper()); System.out.println(stus); } private class StudentRowMapper implements RowMapper&lt;Student&gt;{ public Student mapRow(ResultSet resultSet, int i) throws SQLException { Student stu = new Student(); stu.setId(resultSet.getInt(&quot;id&quot;)); stu.setName(resultSet.getString(&quot;name&quot;)); stu.setSex(resultSet.getString(&quot;sex&quot;)); stu.setBorn(resultSet.getDate(&quot;born&quot;)); return stu; } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"桥接模式","slug":"技术/桥接模式","date":"2020-10-13T16:30:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/14/技术/桥接模式/","link":"","permalink":"/2020/10/14/技术/桥接模式/","excerpt":"","text":"基本介绍 桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。 是一种结构型设计模式 Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的 功能扩展 UML CODE public interface Brand { void open(); void close(); } public class Vivo implements Brand { @Override public void open() { System.out.println(&quot;VIVO手机开机&quot;); } @Override public void close() { System.out.println(&quot;VIVO手机关机&quot;); } } public class Xiaomi implements Brand { @Override public void open() { System.out.println(&quot;Xiaomi手机开机&quot;); } @Override public void close() { System.out.println(&quot;Xiaomi手机关机&quot;); } } public abstract class Phone { private Brand brand; public Phone(Brand brand) { this.brand = brand; } protected void open() { brand.open(); } protected void close() { brand.close(); } } public class FoldedPhone extends Phone { public FoldedPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(&quot;折叠样式手机&quot;); } public void close() { super.close(); System.out.println(&quot;折叠样式手机&quot;); } } public class UpRightPhone extends Phone { //构造器 public UpRightPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(&quot; 直立样式手机 &quot;); } public void close() { super.close(); System.out.println(&quot; 直立样式手机 &quot;); } } public class Client { public static void main(String[] args) { //获取折叠式手机 (样式 + 品牌 ) Phone phone1 = new FoldedPhone(new Xiaomi()); phone1.open(); phone1.close(); System.out.println(&quot;=======================&quot;); Phone phone2 = new FoldedPhone(new Vivo()); phone2.open(); phone2.close(); System.out.println(&quot;==============&quot;); UpRightPhone phone3 = new UpRightPhone(new Xiaomi()); phone3.open(); phone3.close(); System.out.println(&quot;==============&quot;); UpRightPhone phone4 = new UpRightPhone(new Vivo()); phone4.open(); phone4.close(); } } 优缺点 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于 系统进行分层设计，从而产生更好的结构化系统。 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。 桥接模式其它应用场景对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"适配器模式","slug":"技术/适配器模式","date":"2020-10-08T15:30:00.000Z","updated":"2022-10-09T15:19:10.437Z","comments":true,"path":"2020/10/08/技术/适配器模式/","link":"","permalink":"/2020/10/08/技术/适配器模式/","excerpt":"","text":"基本介绍 适配器模式(AdapterPattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本 因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)尚硅谷 Java 设计模式第 9 章 适配器设计模式 9.1 现实生活中的适配器例子 适配器模式属于结构型模式 主要分为三类:类适配器模式、对象适配器模式、接口适配器模式 1.类适配器模式 应用实例说明 以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电 UML CODE public class Voltage220V { public int output220V() { int src = 220; System.out.println(&quot;电压=&quot; + src + &quot;V&quot;); return src; } } public interface IVoltage5V { public int output5V(); } public class VoltageAdapter extends Voltage220V implements IVoltage5V{ @Override public int output5V() { int srcV = output220V(); int dstV = srcV / 44; return dstV; } } public class Client { public static void main(String[] args) { System.out.println(&quot;类适配器模式&quot;); VoltageAdapter voltageAdapter = new VoltageAdapter(); System.out.println(&quot;转换后电压&quot; + voltageAdapter.output5V()); } } 优缺点 Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局 限性; src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。 2.对象适配器模式介绍 根据“合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系。 UML CODE public interface IVoltage5V { public int output5V(); } public class Voltage220V { public int output220V() { int src = 220; System.out.println(&quot;电压=&quot; + src + &quot;V&quot;); return src; } } public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; public VoltageAdapter(Voltage220V voltage220V) { this.voltage220V = voltage220V; } @Override public int output5V() { int srcV = voltage220V.output220V(); int dstV = srcV / 44; return dstV; } } public class Client { public static void main(String[] args) { System.out.println(&quot;类适配器模式&quot;); VoltageAdapter voltageAdapter = new VoltageAdapter(new Voltage220V()); System.out.println(&quot;转换后电压&quot; + voltageAdapter.output5V() + &quot;V&quot;); } } 优缺点 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst 必须是接口。 3.接口适配器模式介绍 一些书籍称为:适配器模式(DefaultAdapterPattern)或缺省适配器模式。 核心思路:当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求 适用于一个接口不想使用其所有的方法的情况。 UML CODE public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } public abstract class AbsAdapter implements Interface4{ //默认实现 @Override public void m1() { } @Override public void m2() { } @Override public void m3() { } @Override public void m4() { } } public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter() { //只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { System.out.println(&quot;m1 method&quot;); } }; absAdapter.m1(); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"建造者模式","slug":"技术/建造者模式","date":"2020-10-08T03:30:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/08/技术/建造者模式/","link":"","permalink":"/2020/10/08/技术/建造者模式/","excerpt":"","text":"基本介绍 建造者模式(BuilderPattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出 来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。 建造者模式的四个角色 Product(产品角色): 一个具体的产品对象。 Builder(抽象建造者): 创建一个 Product 对象的各个部件指定的 接口/抽象类。 ConcreteBuilder(具体建造者): 实现接口，构建和装配各个部件。 Director(指挥者): 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是:隔离了客户与对象的生产过程，二是:负责控制产品对象的生产过程。 建造者模式解决盖房需求 需要建房子:这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们 使用建造者模式(Builder Pattern)来完成 UML CODE public abstract class HouseBuilder { protected House house = new House(); //建造的流程流程写好 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造好房子，将产品返回 public House buildHouse() { return house; } } public class CommonHouseBuilder extends HouseBuilder { @Override public void buildBasic() { System.out.println(&quot;普通房子打地基5米&quot;); } @Override public void buildWalls() { System.out.println(&quot;普通房子砌墙10厘米&quot;); } @Override public void roofed() { System.out.println(&quot;普通房子屋顶&quot;); } } public class HighHouseBuilder extends HouseBuilder { @Override public void buildBasic() { System.out.println(&quot; 高楼的打地基100米 &quot;); } @Override public void buildWalls() { System.out.println(&quot; 高楼的砌墙20厘米 &quot;); } @Override public void roofed() { System.out.println(&quot; 高楼的透明屋顶 &quot;); } } public class HouseDirector { HouseBuilder houseBuilder; public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } public class House { public String base; public String wall; public String rooted; } public class Client { public static void main(String[] args) { HouseDirector houseDirector = new HouseDirector(new CommonHouseBuilder()); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); } } 优点 产品和产品建造过程解耦，便于扩展和维护","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"原型模式","slug":"技术/原型模式","date":"2020-10-07T14:28:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/07/技术/原型模式/","link":"","permalink":"/2020/10/07/技术/原型模式/","excerpt":"","text":"基本介绍 原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 1.基本类型的拷贝CODE public class Sheep implements Cloneable{ public String name; public int age; public Sheep friend;//是对象, 克隆是会如何处理, 默认是浅拷贝 public Sheep(String name, int age) { this.name = name; this.age = age; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } public class Client { public static void main(String[] args) throws CloneNotSupportedException { Sheep sheep1 = new Sheep(&quot;zhangsan&quot;,1); Sheep sheep2 = new Sheep(&quot;lisi&quot;, 2); sheep1.friend = sheep2; sheep2.friend = sheep1; Sheep sheep3 = (Sheep)sheep1.clone(); System.out.println(sheep3 == sheep1);//false System.out.println(sheep3.friend == sheep1.friend);//true } } 注意 成员变量为对象时，克隆是浅拷贝，使用默认拷贝是拷贝的地址 2.深拷贝基本介绍 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝 深拷贝实现方式1:重写clone方法来实现深拷贝 深拷贝实现方式2:通过对象序列化实现深拷贝(推荐) CODE package blog.prototype; import java.io.Serializable; public class DeepCloneableTarget implements Serializable, Cloneable { public String cloneName; public String cloneClass; public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } //因为该类的属性，都是 String , 因此我们这里使用默认的 clone 完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } package blog.prototype; import java.io.*; public class DeepProtoType implements Serializable, Cloneable { public String name; public DeepCloneableTarget deepCloneableTarget; //深拷贝 - 方式 1 使用clone 方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; //这里完成对基本数据类型(属性)和 String 的克隆 deep = super.clone(); //对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType)deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone(); return deepProtoType; } //深拷贝 - 方式 2 通过对象的序列化实现 (推荐) public Object deepClone() { //创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; DeepProtoType copyObj = null; try { //序列化 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); //当前这个对象以对象流的方式输出 //反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); copyObj = (DeepProtoType)ois.readObject(); } catch (Exception e) { e.printStackTrace(); } finally { try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (IOException e) { e.printStackTrace(); } } return copyObj; } } package blog.prototype; public class Client { public static void main(String[] args) throws CloneNotSupportedException { DeepCloneableTarget deepCloneableTarget = new DeepCloneableTarget(&quot;cloneName&quot;,&quot;cloneClass&quot;); DeepProtoType deepProtoType = new DeepProtoType(); deepProtoType.name = &quot;DeepProtoType&quot;; deepProtoType.deepCloneableTarget = deepCloneableTarget; DeepProtoType deepProtoType1 = (DeepProtoType) deepProtoType.clone(); System.out.println(deepProtoType1.name); System.out.println(deepProtoType1.deepCloneableTarget.cloneName); System.out.println(deepProtoType.deepCloneableTarget == deepProtoType1.deepCloneableTarget);//false DeepProtoType deepProtoType2 = (DeepProtoType) deepProtoType.deepClone(); System.out.println(deepProtoType2.name); System.out.println(deepProtoType2.deepCloneableTarget.cloneName); System.out.println(deepProtoType.deepCloneableTarget == deepProtoType2.deepCloneableTarget);//false } } 优缺点 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码 缺点:需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请注意.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"工厂模式","slug":"技术/工厂模式","date":"2020-10-07T06:00:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/07/技术/工厂模式/","link":"","permalink":"/2020/10/07/技术/工厂模式/","excerpt":"","text":"1.简单工厂模式看一个披萨的项目:要便于披萨种类的扩展，要便于维护 披萨的种类很多(比如 GreekPizz、CheesePizz 等) 披萨的制作有 prepare，bake, cut, box 完成披萨店订购功能。 思路 把创建 Pizza 对象封装到一个类中，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza 对象的代码就不需要修改了 UML package blog.factory; import blog.factory.pizza.CheesePizza; import blog.factory.pizza.GreekPizza; import blog.factory.pizza.Pizza; public class SimpleFactory { //简单工厂模式 public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;奶酪&quot;)) { pizza = new CheesePizza(); pizza.setName(&quot;奶酪披萨&quot;); } else if (orderType.equals(&quot;希腊&quot;)) { pizza = new GreekPizza(); pizza.setName(&quot;希腊披萨&quot;); } return pizza; } //简单工厂模式，静态工厂模式 public static Pizza createPizza2(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;奶酪&quot;)) { pizza = new CheesePizza(); pizza.setName(&quot;奶酪披萨&quot;); } else if (orderType.equals(&quot;希腊&quot;)) { pizza = new GreekPizza(); pizza.setName(&quot;希腊披萨&quot;); } return pizza; } } package blog.factory; import blog.factory.pizza.Pizza; public class OrderPizza { private SimpleFactory simpleFactory; public OrderPizza(SimpleFactory simpleFactory) { this.simpleFactory = simpleFactory; } public void makePizza(String orderType) { Pizza pizza = simpleFactory.createPizza(orderType); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } } package blog.factory; public class Test { public static void main(String[] args) { OrderPizza orderPizza = new OrderPizza(new SimpleFactory()); orderPizza.makePizza(&quot;希腊&quot;); } } package blog.factory.pizza; public abstract class Pizza { private String name; //不同类型制作材料的准备不同 public abstract void prepare(); public void bake() { System.out.println(name + &quot;baking&quot;); } public void cut() { System.out.println(name + &quot;cutting&quot;); } public void box() { System.out.println(name + &quot;boxing&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } } package blog.factory.pizza; public class GreekPizza extends Pizza { @Override public void prepare() { System.out.println(&quot;给希腊披萨准备原材料&quot;); } } package blog.factory.pizza; public class CheesePizza extends Pizza{ @Override public void prepare() { System.out.println(&quot;制作奶酪披萨，准备材料&quot;); } } 2.工厂方法模式需求 披萨项目新的需求:客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的希腊 pizza 或 者是伦敦的奶酪 pizza、伦敦的希腊 pizza。 思路 使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好 工厂方法模式设计方案:将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。 工厂方法模式:定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例 化推迟到子类。UML CODE public abstract class PizzaFactory { public abstract Pizza createPizza(String orderType); } public class BJPizzaFactory extends PizzaFactory{ @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new BJGreekPizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new BJGreekPizza(); } return pizza; } } public class LDPizzaFactory extends PizzaFactory{ @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new LDCheesePizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new LDGreekOPizza(); } return pizza; } } public class Order { private PizzaFactory pizzaFactory; public Order(PizzaFactory pizzaFactory) { this.pizzaFactory = pizzaFactory; } public void makePizza(String type) { Pizza pizza = pizzaFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } } public class Client { public static void main(String[] args) { Order order = new Order(new LDPizzaFactory()); order.makePizza(&quot;greek&quot;); } } 3.抽象工厂模式思路 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类，完成了对地点BJ和LD的区分 UML CODE public interface AbsFactory { public Pizza createPizza(String orderType); } public class BJFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new BJCheesePizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new BJGreekPizza(); } return pizza; } } public class LDFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new LDCheesePizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new LDGreekOPizza(); } return pizza; } } public class Order { private AbsFactory absFactory; public Order(AbsFactory absFactory) { this.absFactory = absFactory; } public void makePizza(String type) { Pizza pizza = absFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } } public class Client { public static void main(String[] args) { Order order = new Order(new LDFactory()); order.makePizza(&quot;cheese&quot;); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"单例模式","slug":"技术/单例模式","date":"2020-10-06T14:28:00.000Z","updated":"2022-10-09T15:19:10.433Z","comments":true,"path":"2020/10/06/技术/单例模式/","link":"","permalink":"/2020/10/06/技术/单例模式/","excerpt":"","text":"1.饿汉式(静态常量)package blog.singleton; public class SingletonTest { public static void main(String[] args) { Singleton singleton1 = Singleton.getInstance(); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton1 == singleton2); } } class Singleton { // 1.构造器私有化，防止外部new private Singleton() {} // 2.在装载时，完成实例化 private final static Singleton instance = new Singleton(); // 3.通过公有静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } 优点 类装载的时候就完成实例化。避免了线程同步问题。 缺点 在类装载的时候就完成实例化，没有达到LazyLoading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大 多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式(或者其他的静 态方法)导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果 结论 这种单例模式可用，可能造成内存浪费 2.饿汉式(静态代码块)class Singleton { private Singleton() {} private static Singleton instance; { instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 优点缺点这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执 行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。 结论这种单例模式可用，但是可能造成内存浪费 3.懒汉式(线程不安全)class Singleton { private static Singleton instance; private Singleton(){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 优缺点 起到了LazyLoading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式 结论 实际开发中，不要使用这种方式. 4.懒汉式(线程安全，同步方法，不推荐使用)class Singleton { private static Singleton instance; private Singleton(){}; //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 优缺点 解决了线程安全问题 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低 结论 实际开发中，不推荐使用这种方式 5. 懒汉式(线程安全，同步代码块，不推荐)class Singleton { private static Singleton instance; private Singleton(){}; public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { instance = new Singleton(); } } return instance; } } 优缺点 与上一个模式同样，解决了线程安全问题，但效率太低了 6.双重检查(推荐使用)class Singleton { private static volatile Singleton instance;//volatile 很重要 private Singleton() {} //加入双重检查代码，解决线程安全问题, 同时解决懒加载问题,同时保证了效率, 推荐使用 public static synchronized Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 优缺点 Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了。 这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避 免的反复进行方法同步. 线程安全;延迟加载;效率较高 volatile 禁止指令重排 结论 在实际开发中，推荐使用这种单例设计模式 7.静态内部类(推荐)class Singleton { private static volatile Singleton instance;//volatile 很重要 private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; } } 优缺点 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 结论 推荐使用 8.枚举（推荐使用）package blog.singleton; public class SingletonTest { public static void main(String[] args) { Singleton singleton1 = Singleton.INSTANCE; Singleton singleton2 = Singleton.INSTANCE; System.out.println(singleton1 == singleton2); singleton1.sayOk(); } } // enum Singleton { INSTANCE;//枚举实例 public void sayOk() { System.out.println(&quot;ok~&quot;); } } 优缺点 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建 新的对象。 这种方式是EffectiveJava作者JoshBloch提倡的方式 结论 推荐使用 9.使用场景需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}